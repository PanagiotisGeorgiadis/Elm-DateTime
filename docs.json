[{"name":"Calendar","comment":" The [Calendar](Calendar#) module was introduced in order to keep track of the `Calendar Date` concept.\nIt has no knowledge of `Time` therefore it can only represent a [Date](Calendar#Date)\nwhich consists of a `Day`, a `Month` and a `Year`. You can construct a `Calendar Date` either\nfrom a [Posix](https://package.elm-lang.org/packages/elm/time/latest/Time#Posix) time or by\nusing its [Raw constituent parts](Calendar#RawDate). You can use a `Date` and the\nCalendar's utilities as a standalone or you can combine a [Date](Calendar#Date) and a\n[Time](Clock#Time) in order to get a [DateTime](DateTime#DateTime) which can then be converted into\na [Posix](https://package.elm-lang.org/packages/elm/time/latest/Time#Posix).\n\n\n# Type definition\n\n@docs Date, RawDate\n\n\n# Creating a `Date`\n\n@docs fromPosix, fromRawParts\n\n\n# Conversions\n\n@docs toMillis, monthToInt\n\n\n# Accessors\n\n@docs getYear, getMonth, getDay\n\n\n# Setters\n\n@docs setYear, setMonth, setDay\n\n\n# Increment values\n\n@docs incrementYear, incrementMonth, incrementDay\n\n\n# Decrement values\n\n@docs decrementYear, decrementMonth, decrementDay\n\n\n# Compare values\n\n@docs compare\n\n\n# Utilities\n\n@docs getDateRange, getDatesInMonth, getDayDiff, getFollowingMonths, getPrecedingMonths, getWeekday, isLeapYear, sort\n\n\n# Constants\n\n@docs months, millisInADay\n\n","unions":[],"aliases":[{"name":"Date","comment":" A full ([Gregorian](https://en.wikipedia.org/wiki/Gregorian_calendar)) calendar date.\n","args":[],"type":"Calendar.Internal.Date"},{"name":"RawDate","comment":" The raw representation of a calendar date.\n","args":[],"type":"{ year : Basics.Int, month : Time.Month, day : Basics.Int }"}],"values":[{"name":"compare","comment":" Compares the two given [Dates](Calendar#Date) and returns an [Order](https://package.elm-lang.org/packages/elm/core/latest/Basics#Order).\n\n    -- past   == 25 Aug 2019\n    -- future == 26 Aug 2019\n    compare past past -- EQ : Order\n\n    compare past future -- LT : Order\n\n    compare future past -- GT : Order\n\n","type":"Calendar.Date -> Calendar.Date -> Basics.Order"},{"name":"decrementDay","comment":" Decrements the `Day` in a given [Date](Calendar#Date). Will also decrement `Month` and `Year` where applicable.\n\n    -- date  == 27 Aug 2019\n    decrementDay date -- 26 Aug 2019 : Date\n\n    -- date2 == 1 Jan 2020\n    decrementDay date2 -- 31 Dec 2019 : Date\n\n","type":"Calendar.Date -> Calendar.Date"},{"name":"decrementMonth","comment":" Decrements the `Month` in a given [Date](Calendar#Date). It will also roll backwards to the previous year where applicable.\n\n    -- date  == 15 Sep 2019\n    decrementMonth date -- 15 Aug 2019 : Date\n\n    -- date2 == 15 Jan 2020\n    decrementMonth date2 -- 15 Dec 2019 : Date\n\n    -- date3 == 31 Dec 2019\n    decrementMonth date3 -- 30 Nov 2019 : Date\n\n**Note:** In the first example, decrementing the `Month` causes no changes in the `Year` and `Day` parts while\non the second example it rolls backwards the `Year`. On the last example we see that the `Day` part is different\nthan the input. This is because the resulting date would be an invalid one ( _**31st of November 2019**_ ). As a result\nof this scenario we fall back to the last valid day of the given `Month` and `Year` combination.\n\n","type":"Calendar.Date -> Calendar.Date"},{"name":"decrementYear","comment":" Decrements the `Year` in a given [Date](Calendar#Date) while preserving the `Month` and `Day` parts.\n\n    -- date  == 31 Jan 2019\n    decrementYear date -- 31 Jan 2018 : Date\n\n    -- date2 == 29 Feb 2020\n    decrementYear date2 -- 28 Feb 2019 : Date\n\n**Note:** In the first example, decrementing the `Year` causes no changes in the `Month` and `Day` parts.\nOn the second example we see that the `Day` part is different than the input. This is because the resulting date\nwould be an invalid date ( _**29th of February 2019**_ ). As a result of this scenario we fall back to the last\nvalid day of the given `Month` and `Year` combination.\n\n","type":"Calendar.Date -> Calendar.Date"},{"name":"fromPosix","comment":" Construct a [Date](Calendar#Date) from a [Posix](https://package.elm-lang.org/packages/elm/time/latest/Time#Posix) time.\nYou can construct a `Posix` time from milliseconds using the [millisToPosix](https://package.elm-lang.org/packages/elm/time/latest/Time#millisToPosix)\nfunction located in the [elm/time](https://package.elm-lang.org/packages/elm/time/latest/) package.\n\n    fromPosix (Time.millisToPosix 0)\n    -- Date { day = Day 1, month = Jan, year = Year 1970 } : Date\n\n    fromPosix (Time.millisToPosix 1566795954000)\n    -- Date { day = Day 26, month = Aug, year = Year 2019 } : Date\n\n    fromPosix (Time.millisToPosix 1566777600000)\n    -- Date { day = Day 26, month = Aug, year = Year 2019 } : Date\n\nNotice that in the second and third examples the timestamps that are used are different but the resulting [Dates](Calendar#Date) are identical.\nThis is because the [Calendar](Calendar#) module doesn't have any knowledge of `Time` which means that if we attempt to convert both of these dates back [toMillis](Calendar#toMillis)\nthey will result in the same milliseconds. It is recommended using the [fromPosix](DateTime#fromPosix) function provided in the [DateTime](DateTime#)\nmodule if you need to preserve both `Date` and `Time`.\n\n","type":"Time.Posix -> Calendar.Date"},{"name":"fromRawParts","comment":" Attempt to construct a [Date](Calendar#Date) from its (raw) constituent parts.\nReturns `Nothing` if any parts or their combination would form an invalid date.\n\n    fromRawParts { day = 25, month = Dec, year = 2019 }\n    -- Just (Date { day = Day 25, month = Dec, year = Year 2019 }) : Maybe Date\n\n    fromRawParts { day = 29, month = Feb, year = 2019 }\n    -- Nothing : Maybe Date\n\n","type":"Calendar.RawDate -> Maybe.Maybe Calendar.Date"},{"name":"getDateRange","comment":" Returns an incrementally sorted [Date](Calendar#Date) list based on the **start** and **end** date parameters.\n_**The resulting list will include both start and end dates**_.\n\n    -- start == 26 Feb 2020\n    -- end   == 1 Mar 2020\n\n    getDateRange start end\n    -- [ 26 Feb 2020, 27 Feb 2020, 28 Feb 2020, 29 Feb 2020, 1  Mar 2020 ] : List Date\n\n    getDateRange end start\n    -- [ 26 Feb 2020, 27 Feb 2020, 28 Feb 2020, 29 Feb 2020, 1  Mar 2020 ] : List Date\n\n","type":"Calendar.Date -> Calendar.Date -> List.List Calendar.Date"},{"name":"getDatesInMonth","comment":" Returns a list of [Dates](Calendar#Date) for the given `Year` and `Month` combination.\n\n    -- date == 26 Aug 2019\n\n    getDatesInMonth date\n    -- [ 1 Aug 2019, 2 Aug 2019, 3 Aug 2019, ..., 29 Aug 2019, 30 Aug 2019, 31 Aug 2019 ] : List Date\n\n","type":"Calendar.Date -> List.List Calendar.Date"},{"name":"getDay","comment":" Extract the `Day` part of a [Date](Calendar#Date).\n\n    -- date == 25 Dec 2019\n    getDay date -- 25 : Int\n\n","type":"Calendar.Date -> Basics.Int"},{"name":"getDayDiff","comment":" Returns the difference in days between two [Dates](Calendar#Date). We can have a negative difference of days as can be seen in the examples below.\n\n    -- past   == 24 Aug 2019\n    -- future == 26 Aug 2019\n    getDayDiff past future -- 2  : Int\n\n    getDayDiff future past -- -2 : Int\n\n","type":"Calendar.Date -> Calendar.Date -> Basics.Int"},{"name":"getFollowingMonths","comment":" Returns a list with all the following months in a Calendar Year based on the `Month` argument provided.\nThe resulting list **will not include** the given `Month`.\n\n    getFollowingMonths Aug -- [ Sep, Oct, Nov, Dec ] : List Month\n\n    getFollowingMonths Dec -- [] : List Month\n\n","type":"Time.Month -> List.List Time.Month"},{"name":"getMonth","comment":" Extract the `Month` part of a [Date](Calendar#Date).\n\n    -- date == 25 Dec 2019\n    getMonth date -- Dec : Month\n\n","type":"Calendar.Date -> Time.Month"},{"name":"getPrecedingMonths","comment":" Returns a list with all the preceding months in a Calendar Year based on the `Month` argument provided.\nThe resulting list **will not include** the given `Month`.\n\n    getPrecedingMonths May -- [ Jan, Feb, Mar, Apr ] : List Month\n\n    getPrecedingMonths Jan -- [] : List Month\n\n","type":"Time.Month -> List.List Time.Month"},{"name":"getWeekday","comment":" Returns the weekday of a specific [Date](Calendar#Date).\n\n    -- date == 26 Aug 2019\n    getWeekday date -- Mon : Weekday\n\n","type":"Calendar.Date -> Time.Weekday"},{"name":"getYear","comment":" Extract the `Year` part of a [Date](Calendar#Date).\n\n    -- date == 25 Dec 2019\n    getYear date -- 2019 : Int\n\n","type":"Calendar.Date -> Basics.Int"},{"name":"incrementDay","comment":" Increments the `Day` in a given [Date](Calendar#Date). Will also increment `Month` and `Year` where applicable.\n\n    -- date  == 25 Aug 2019\n    incrementDay date -- 26 Aug 2019 : Date\n\n    -- date2 == 31 Dec 2019\n    incrementDay date2 -- 1 Jan 2020 : Date\n\n","type":"Calendar.Date -> Calendar.Date"},{"name":"incrementMonth","comment":" Increments the `Month` in a given [Date](Calendar#Date). It will also roll over to the next year where applicable.\n\n    -- date  == 15 Sep 2019\n    incrementMonth date -- 15 Oct 2019 : Date\n\n    -- date2 == 15 Dec 2019\n    incrementMonth date2 -- 15 Jan 2020 : Date\n\n    -- date3 == 31 Jan 2019\n    incrementMonth date3 -- 28 Feb 2019 : Date\n\n**Note:** In the first example, incrementing the `Month` causes no changes in the `Year` and `Day` parts while on the second\nexample it rolls forward the 'Year'. On the last example we see that the `Day` part is different than the input. This is because\nthe resulting date would be an invalid one ( _**31st of February 2019**_ ). As a result of this scenario we fall back to the last\nvalid day of the given `Month` and `Year` combination.\n\n","type":"Calendar.Date -> Calendar.Date"},{"name":"incrementYear","comment":" Increments the `Year` in a given [Date](Calendar#Date) while preserving the `Month` and `Day` parts.\n\n    -- date  == 31 Jan 2019\n    incrementYear date -- 31 Jan 2020 : Date\n\n    -- date2 == 29 Feb 2020\n    incrementYear date2 -- 28 Feb 2021 : Date\n\n**Note:** In the first example, incrementing the `Year` causes no changes in the `Month` and `Day` parts.\nOn the second example we see that the `Day` part is different than the input. This is because the resulting date\nwould be an invalid date ( _**29th of February 2021**_ ). As a result of this scenario we fall back to the last valid day\nof the given `Month` and `Year` combination.\n\n","type":"Calendar.Date -> Calendar.Date"},{"name":"isLeapYear","comment":" Checks if the `Year` part of the given [Date](Calendar#Date) is a leap year.\n\n    -- date  == 25 Dec 2019\n    isLeapYear date -- False\n\n    -- date2 == 25 Dec 2020\n    isLeapYear date2 -- True\n\n","type":"Calendar.Date -> Basics.Bool"},{"name":"millisInADay","comment":" Returns the milliseconds in a day.\n","type":"Basics.Int"},{"name":"monthToInt","comment":" Convert a given [Month](https://package.elm-lang.org/packages/elm/time/latest/Time#Month) to an integer starting from 1.\n\n    monthToInt Jan -- 1 : Int\n\n    monthToInt Aug -- 8 : Int\n\n","type":"Time.Month -> Basics.Int"},{"name":"months","comment":" Returns a list of all the `Months` in Calendar order.\n","type":"Array.Array Time.Month"},{"name":"setDay","comment":" Attempts to set the `Day` part of a [Date](Calendar#Date).\n\n    -- date == 31 Jan 2019\n    setDay 25 date -- Just (25 Jan 2019) : Maybe Date\n\n    setDay 32 date -- Nothing : Maybe Date\n\n","type":"Basics.Int -> Calendar.Date -> Maybe.Maybe Calendar.Date"},{"name":"setMonth","comment":" Attempts to set the `Month` part of a [Date](Calendar#Date).\n\n    -- date == 31 Jan 2019\n    setMonth Aug date -- Just (31 Aug 2019) : Maybe Date\n\n    setMonth Apr date -- Nothing : Maybe Date\n\n","type":"Time.Month -> Calendar.Date -> Maybe.Maybe Calendar.Date"},{"name":"setYear","comment":" Attempts to set the `Year` part of a [Date](Calendar#Date).\n\n    -- date == 29 Feb 2020\n    setYear 2024 date -- Just (29 Feb 2024) : Maybe Date\n\n    setYear 2019 date -- Nothing : Maybe Date\n\n","type":"Basics.Int -> Calendar.Date -> Maybe.Maybe Calendar.Date"},{"name":"sort","comment":" Sorts incrementally a list of [Dates](Calendar#Date).\n\n    -- past   == 26 Aug 1920\n    -- epoch  == 1 Jan 1970\n    -- future == 25 Dec 2020\n\n    sort [ future, past, epoch ]\n    -- [ 26 Aug 1920, 1 Jan 1970, 25 Dec 2020 ] : List Date\n\n","type":"List.List Calendar.Date -> List.List Calendar.Date"},{"name":"toMillis","comment":" Transforms a [Date](Calendar#Date) into milliseconds.\n\n    date = fromRawParts { day = 25, month = Dec, year = 2019 }\n    Maybe.map toMillis date -- Just 1577232000000 == 25 Dec 2019 00:00:00.000\n\n    want = 1566795954000 -- 26 Aug 2019 05:05:54.000\n    got = toMillis (fromPosix (Time.millisToPosix want)) -- 1566777600000 == 26 Aug 2019 00:00:00.000\n\n    want == got -- False\n\nNotice that transforming a **date** to milliseconds will always get you midnight hours.\nThe first example above will return a timestamp that equals to **Wed 25th of December 2019 00:00:00.000**\nand the second example will return a timestamp that equals to **26th of August 2019 00:00:00.000** even though\nthe timestamp we provided in the [fromPosix](Calendar#fromPosix) was equal to **26th of August 2019 05:05:54.000**\n\n","type":"Calendar.Date -> Basics.Int"}],"binops":[]},{"name":"Clock","comment":" The [Clock](Clock#) module was introduced in order to keep track of the `Time` concept.\nIt has no notion of a `Date` or any of its parts and it represents `Time` as a [24-hour clock](https://en.wikipedia.org/wiki/24-hour_clock)\nwhich consists of `Hours`, `Minutes`, `Seconds` and `Milliseconds`. You can construct a `Time`\neither by providing a [Posix](https://package.elm-lang.org/packages/elm/time/latest/Time#Posix) time\nor by using its [Raw constituent parts](Clock#RawTime). You can use a `Time` and\nthe Clock's utilities as a standalone or you can combine a [Time](Clock#Time) and a [Date](Calendar#Date)\nin order to get a [DateTime](DateTime#DateTime) which can then be converted into a [Posix](https://package.elm-lang.org/packages/elm/time/latest/Time#Posix).\n\n\n# Type definition\n\n@docs Time, RawTime\n\n\n# Creating a `Time`\n\n@docs fromPosix, fromRawParts\n\n\n# Conversions\n\n@docs toMillis\n\n\n# Accessors\n\n@docs getHours, getMinutes, getSeconds, getMilliseconds\n\n\n# Setters\n\n@docs setHours, setMinutes, setSeconds, setMilliseconds\n\n\n# Increment values\n\n@docs incrementHours, incrementMinutes, incrementSeconds, incrementMilliseconds\n\n\n# Decrement values\n\n@docs decrementHours, decrementMinutes, decrementSeconds, decrementMilliseconds\n\n\n# Compare values\n\n@docs compare\n\n\n# Utilities\n\n@docs sort\n\n\n# Constants\n\n@docs midnight\n\n","unions":[],"aliases":[{"name":"RawTime","comment":" An 'abstract' representation of Time and its constituent parts based on Integers.\n","args":[],"type":"{ hours : Basics.Int, minutes : Basics.Int, seconds : Basics.Int, milliseconds : Basics.Int }"},{"name":"Time","comment":" A clock time.\n","args":[],"type":"Clock.Internal.Time"}],"values":[{"name":"compare","comment":" Compare two `Time` values.\n\n    -- past   == 15:45:24.780\n    -- future == 15:45:24.800\n    compare past past -- EQ : Order\n\n    compare past future -- LT : Order\n\n    compare future past -- GT : Order\n\n","type":"Clock.Time -> Clock.Time -> Basics.Order"},{"name":"decrementHours","comment":" Decrements an `Hour` inside a [Time](Clock#Time). The [Time](Clock#Time) will keep on cycling backwards with a\nminimum time of _00:00:00.000_. It also returns a `Bool` flag which indicates if the new `Time` has passed through the midnight hour ( 00:00:00.000 ).\nThis flag can be used in order to notify that a `Day` has passed but it is advised to use the [DateTime](DateTime#) module for these kind\nof operations since it provides all the available helpers and takes care of any [Calendar](Calendar#) changes.\n\n    -- time  == 13:15:45.750\n    decrementHours time -- (12:15:45.750, False) : (Time, Bool)\n\n    -- time2 == 00:59:59.999\n    decrementHours time2 -- (23:59:59.999, True) : (Time, Bool)\n\n","type":"Clock.Time -> ( Clock.Time, Basics.Bool )"},{"name":"decrementMilliseconds","comment":" Decrements a `Millisecond` inside a [Time](Clock#Time). The [Time](Clock#Time) will keep on cycling backwards\nas mentioned in the [decrementHours](Clock#decrementHours) description.\n\n    -- time  == 12:15:00.000\n    decrementMilliseconds time -- (12:14:59.999, False) : (Time, Bool)\n\n    -- time2 == 00:00:00.000\n    decrementMilliseconds time2 -- (23:59:59.999, True) : (Time, Bool)\n\n","type":"Clock.Time -> ( Clock.Time, Basics.Bool )"},{"name":"decrementMinutes","comment":" Decrements a `Minute` inside a [Time](Clock#Time). The [Time](Clock#Time) will keep on cycling backwards\nas mentioned in the [decrementHours](Clock#decrementHours) description.\n\n    -- time  == 12:15:00.000\n    decrementMinutes time -- (12:14:00.000, False) : (Time, Bool)\n\n    -- time2 == 00:00:00.000\n    decrementMinutes time2 -- (23:59:00.000, True) : (Time, Bool)\n\n","type":"Clock.Time -> ( Clock.Time, Basics.Bool )"},{"name":"decrementSeconds","comment":" Decrements a `Second` inside a [Time](Clock#Time). The [Time](Clock#Time) will keep on cycling backwards\nas mentioned in the [decrementHours](Clock#decrementHours) description.\n\n    -- time  == 12:15:00.000\n    decrementSeconds time -- (12:14:59.000, False) : (Time, Bool)\n\n    -- time2 == 00:00:00.000\n    decrementSeconds time2 -- (23:59:59.000, True) : (Time, Bool)\n\n","type":"Clock.Time -> ( Clock.Time, Basics.Bool )"},{"name":"fromPosix","comment":" Construct a [Time](Clock#Time) from a [Posix](https://package.elm-lang.org/packages/elm/time/latest/Time#Posix) time.\nYou can construct a `Posix` time from milliseconds using the [millisToPosix](https://package.elm-lang.org/packages/elm/time/latest/Time#millisToPosix)\nfunction located in the [elm/time](https://package.elm-lang.org/packages/elm/time/latest/) package.\n\n    fromPosix (Time.millisToPosix 0)\n    -- Time { hours = Hour 0, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 0 } : Time\n\n    fromPosix (Time.millisToPosix 1566795954000)\n    -- Time { hours = Hour 5, minutes = Minute 5, seconds = Second 54, milliseconds = Millisecond 0 } : Time\n\n    fromPosix (Time.millisToPosix 1566777600000)\n    -- Time { hours = Hour 0, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 0 } : Time\n\nNotice that in the first and third examples the timestamps that are used are different but the result [Times](Clock#Time) are identical.\nThis is because the [Clock](Clock#) module only extracts the `Hours`, `Minutes`, `Seconds` and `Milliseconds` from the given\n[Posix](https://package.elm-lang.org/packages/elm/time/latest/Time#Posix) time given. This means that if we attempt to convert both of these `Times`\nback [toMillis](Clock#toMillis) they will result in the same milliseconds. It is recommended using the [fromPosix](DateTime#fromPosix)\nfunction provided in the [DateTime](DateTime#) module if you need to preserve both `Date` and `Time`.\n\n","type":"Time.Posix -> Clock.Time"},{"name":"fromRawParts","comment":" Construct a clock [Time](Clock#Time) from raw `Hour`, `Minute`, `Second`, `Millisecond` integers.\n\n    fromRawParts { hours = 23, minutes = 15, seconds = 45, milliseconds = 999 }\n    -- Just (Time { hours = Hour 23, minutes = Minute 15, seconds = Second 45, milliseconds = Millisecond 999 }) : Maybe Time\n\n    fromRawParts { hours = 24, minutes = 15, seconds = 45, milliseconds = 999 }\n    -- Nothing : Maybe Time\n\nNotice that the second attempt to construct a time resulted in `Nothing`. This is because the upper limit for an `Hour` is 23.\n\nThe limits are as follows:\n\n  - 0 &le; Hours &lt; 24\n  - 0 &le; Minutes &lt; 60\n  - 0 &le; Seconds &lt; 60\n  - 0 &le; Milliseconds &lt; 1000\n\n","type":"Clock.RawTime -> Maybe.Maybe Clock.Time"},{"name":"getHours","comment":" Extract the `Hours` part of a [Time](Clock#Time).\n\n    -- time == 12:15:45.500\n    getHours time -- 12 : Int\n\n","type":"Clock.Time -> Basics.Int"},{"name":"getMilliseconds","comment":" Extract the `Millisecond` part of a [Time](Clock#Time).\n\n    -- time == 12:15:45.500\n    getMilliseconds time -- 500 : Int\n\n","type":"Clock.Time -> Basics.Int"},{"name":"getMinutes","comment":" Extract the `Minutes` part of a [Time](Clock#Time).\n\n    -- time == 12:15:45.500\n    getMinutes time -- 15 : Int\n\n","type":"Clock.Time -> Basics.Int"},{"name":"getSeconds","comment":" Extract the `Seconds` part of a [Time](Clock#Time).\n\n    -- time == 12:15:45.500\n    getSeconds time -- 45 : Int\n\n","type":"Clock.Time -> Basics.Int"},{"name":"incrementHours","comment":" Increments an `Hour` inside a [Time](Clock#Time). The [Time](Clock#Time) will keep on cycling forward with a\nmaximum time of _23:59:59.999_. It also returns a `Bool` flag which indicates if the new `Time` has passed through the midnight hour ( 00:00:00.000 ).\nThis flag can be used in order to notify that a `Day` has passed but it is advised to use the [DateTime](DateTime#) module for these kind\nof operations since it provides all the available helpers and takes care of any [Calendar](Calendar#) changes.\n\n-- time == 12:15:45.750\nincrementHours time -- (13:15:45.750, False) : (Time, Bool)\n\n-- time2 == 23:00:00.000\nincrementHours time2 -- (00:00:00.000, True) : (Time, Bool)\n\n","type":"Clock.Time -> ( Clock.Time, Basics.Bool )"},{"name":"incrementMilliseconds","comment":" Increments a `Millisecond` inside a [Time](Clock#Time). The [Time](Clock#Time) will keep on cycling around\nas mentioned in the [incrementHours](Clock#incrementHours) description.\n\n-- time == 12:59:59.999\nincrementMilliseconds time -- (13:00:00.000, False) : (Time, Bool)\n\n-- time2 == 23:59:59.999\nincrementMilliseconds time2 -- (00:00:00.000, True) : (Time, Bool)\n\n","type":"Clock.Time -> ( Clock.Time, Basics.Bool )"},{"name":"incrementMinutes","comment":" Increments a `Minute` inside a [Time](Clock#Time). The [Time](Clock#Time) will keep on cycling around\nas mentioned in the [incrementHours](Clock#incrementHours) description.\n\n-- time == 12:59:45.750\nincrementMinutes time -- (13:00:45.750, False) : (Time, Bool)\n\n-- time2 == 23:59:45.750\nincrementMinutes time2 -- (00:00:45.750, True) : (Time, Bool)\n\n","type":"Clock.Time -> ( Clock.Time, Basics.Bool )"},{"name":"incrementSeconds","comment":" Increments a `Second` inside a [Time](Clock#Time). The [Time](Clock#Time) will keep on cycling around\nas mentioned in the [incrementHours](Clock#incrementHours) description.\n\n-- time == 12:59:59.750\nincrementSeconds time -- (13:00:00.750, False) : (Time, Bool)\n\n-- time2 == 23:59:59.750\nincrementSeconds time2 -- (00:00:00.750, True) : (Time, Bool)\n\n","type":"Clock.Time -> ( Clock.Time, Basics.Bool )"},{"name":"midnight","comment":" Returns midnight time.\n\n    midnight == 00:00:00.000\n\n","type":"Clock.Time"},{"name":"setHours","comment":" Attempts to set the `Hour` on an existing time.\n\n    -- time == 15:45:54.250\n    setHours 23 time -- Just (23:45:54.250) : Maybe Time\n\n    setHours 24 time -- Nothing : Maybe Time\n\n","type":"Basics.Int -> Clock.Time -> Maybe.Maybe Clock.Time"},{"name":"setMilliseconds","comment":" Attempts to set the `Millisecond` on an existing time.\n\n    -- time == 15:45:54.250\n    setMilliseconds 589 time -- Just (15:45:54.589) : Maybe Time\n\n    setMilliseconds 1000 time -- Nothing : Maybe Time\n\n","type":"Basics.Int -> Clock.Time -> Maybe.Maybe Clock.Time"},{"name":"setMinutes","comment":" Attempts to set the `Minute` on an existing time.\n\n    -- time == 15:45:54.250\n    setMinutes 36 time -- Just (15:36:54.250) : Maybe Time\n\n    setMinutes 60 time -- Nothing : Maybe Time\n\n","type":"Basics.Int -> Clock.Time -> Maybe.Maybe Clock.Time"},{"name":"setSeconds","comment":" Attempts to set the `Second` on an existing time.\n\n    -- time == 15:45:54.250\n    setSeconds 20 time -- Just (15:45:20.250) : Maybe Time\n\n    setSeconds 60 time -- Nothing : Maybe Time\n\n","type":"Basics.Int -> Clock.Time -> Maybe.Maybe Clock.Time"},{"name":"sort","comment":" Sorts a List of 'Time' based on their representation in milliseconds.\n\n    -- dawn     == 06:00:00.000\n    -- noon     == 12:00:00.000\n    -- dusk     == 18:00:00.000\n    -- midnight == 00:00:00.000\n\n    sort [ noon, dawn, dusk, midnight ]\n    -- [ 00:00:00.000, 06:00:00.000, 12:00:00.000, 18:00:00.000 ] : List Time\n\n","type":"List.List Clock.Time -> List.List Clock.Time"},{"name":"toMillis","comment":" Convert a [Time](Clock#Time) to milliseconds since midnight.\n\n    time = fromRawParts { hours = 12, minutes = 30, seconds = 0, milliseconds = 0 }\n    Maybe.map toMillis time -- Just 45000000 : Maybe Int\n\n    want = 1566777600000 -- 26 Aug 2019 00:00:00.000\n    got = toMillis (fromPosix (Time.millisToPosix want)) -- 0 : Int\n\n    want == got -- False\n\n","type":"Clock.Time -> Basics.Int"}],"binops":[]},{"name":"DateTime","comment":" The [DateTime](DateTime#) module was introduced in order to keep track of both the\n[Date](Calendar#Date) and [Time](Clock#Time). The `DateTime`\nconsists of a `Day`, `Month`, `Year`, `Hours`, `Minutes`, `Seconds` and `Milliseconds`.\nYou can construct a `DateTime` either by using a [Posix](https://package.elm-lang.org/packages/elm/time/latest/Time#Posix)\nor by using an existing [Date](Calendar#Date) and [Time](Clock#Time) combination. Otherwise\nyou can _**attempt**_ to construct a `DateTime` by using a combination of a\n[RawDate](Calendar#RawDate) and a [RawClock](Clock#RawClock).\n\n@docs DateTime\n\n\n# Creating a `DateTime`\n\n@docs fromPosix, fromRawParts, fromDateAndTime\n\n\n# Conversions\n\n@docs toPosix, toMillis\n\n\n# Accessors\n\n@docs getDate, getTime, getYear, getMonth, getDay, getHours, getMinutes, getSeconds, getMilliseconds\n\n\n# Setters\n\n@docs setYear, setMonth, setDay, setHours, setMinutes, setSeconds, setMilliseconds\n\n\n# Increment values\n\n@docs incrementYear, incrementMonth, incrementDay, incrementHours, incrementMinutes, incrementSeconds, incrementMilliseconds\n\n\n# Decrement values\n\n@docs decrementYear, decrementMonth, decrementDay, decrementHours, decrementMinutes, decrementSeconds, decrementMilliseconds\n\n\n# Compare values\n\n@docs compare, compareDates, compareTime\n\n\n# Utilities\n\n@docs getDateRange, getDatesInMonth, getDayDiff, getWeekday, isLeapYear, sort\n\n","unions":[],"aliases":[{"name":"DateTime","comment":" An instant in time, composed of a [Date](Calendar#Date) and a [Time](Clock#Time).\n","args":[],"type":"DateTime.Internal.DateTime"}],"values":[{"name":"compare","comment":" Compares the two given [DateTimes](DateTime#DateTime) and returns an [Order](https://package.elm-lang.org/packages/elm/core/latest/Basics#Order).\n\n    -- past   == 25 Aug 2019 12:15:45.250\n    -- future == 26 Aug 2019 12:15:45.250\n    compare past past -- EQ : Order\n\n    compare past future -- LT : Order\n\n    compare future past -- GT : Order\n\n","type":"DateTime.DateTime -> DateTime.DateTime -> Basics.Order"},{"name":"compareDates","comment":" Compares the [Date](Calendar#Date) part of two given [DateTime](DateTime#DateTime) and returns an [Order](https://package.elm-lang.org/packages/elm/core/latest/Basics#Order).\n\n    -- dateTime  == 25 Aug 2019 12:15:45.250\n    -- dateTime2 == 25 Aug 2019 21:00:00.000\n    -- dateTime3 == 26 Aug 2019 12:15:45.250\n    compare dateTime dateTime2 -- EQ : Order\n\n    compare dateTime dateTime3 -- LT : Order\n\n    compare dateTime3 dateTime2 -- GT : Order\n\n","type":"DateTime.DateTime -> DateTime.DateTime -> Basics.Order"},{"name":"compareTime","comment":" Compares the [Time](Clock#Time) part of two given [DateTime](DateTime#DateTime) and returns an [Order](https://package.elm-lang.org/packages/elm/core/latest/Basics#Order).\n\n    -- dateTime  == 25 Aug 2019 12:15:45.250\n    -- dateTime2 == 25 Aug 2019 21:00:00.000\n    -- dateTime3 == 26 Aug 2019 12:15:45.250\n    compare dateTime dateTime3 -- EQ : Order\n\n    compare dateTime dateTime2 -- LT : Order\n\n    compare dateTime2 dateTime3 -- GT : Order\n\n","type":"DateTime.DateTime -> DateTime.DateTime -> Basics.Order"},{"name":"decrementDay","comment":" Decrements the `Day` in a given [DateTime](DateTime#DateTime). Will also decrement `Month` and `Year` where applicable.\n\n    -- dateTime  == 27 Aug 2019 15:30:45.100\n    decrementDay dateTime -- 26 Aug 2019 15:30:45.100 : DateTime\n\n    -- dateTime2 == 1 Jan 2020 15:30:45.100\n    decrementDay dateTime2 -- 31 Dec 2019 15:30:45.100 : DateTime\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"decrementHours","comment":" Decrements the `Hours` in a given [DateTime](DateTime#DateTime). Will also decrement `Day`, `Month`, `Year` where applicable.\n\n    -- dateTime  == 25 Aug 2019 15:30:45.100\n    decrementHours dateTime -- 25 Aug 2019 14:30:45.100 : DateTime\n\n    -- dateTime2 == 1 Jan 2020 00:00:00.000\n    decrementHours dateTime2 -- 31 Dec 2019 23:00:00.000 : DateTime\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"decrementMilliseconds","comment":" Decrements the `Milliseconds` in a given [DateTime](DateTime#DateTime). Will also decrement `Seconds`, `Minutes`, `Hours`, `Day`, `Month`, `Year` where applicable.\n\n    -- dateTime  == 25 Aug 2019 15:30:45.100\n    decrementMilliseconds dateTime -- 25 Aug 2019 15:30:45.099 : DateTime\n\n    -- dateTime2 == 1 Jan 2020 00:00:00.000\n    decrementMilliseconds dateTime2 -- 31 Dec 2019 23:59:59.999 : DateTime\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"decrementMinutes","comment":" Decrements the `Minutes` in a given [DateTime](DateTime#DateTime). Will also decrement `Hours`, `Day`, `Month`, `Year` where applicable.\n\n    -- dateTime  == 25 Aug 2019 15:30:45.100\n    decrementMinutes dateTime -- 25 Aug 2019 15:29:45.100 : DateTime\n\n    -- dateTime2 == 1 Jan 2020 00:00:00.000\n    decrementMinutes dateTime2 -- 31 Dec 2019 23:59:00.000 : DateTime\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"decrementMonth","comment":" Decrements the `Month` in a given [DateTime](DateTime#DateTime). It will also roll backwards to the previous year where applicable.\n_The [Time](Clock#Time) related parts will remain the same._\n\n    -- dateTime  == 15 Sep 2019 15:30:45.100\n    decrementMonth dateTime -- 15 Aug 2019 15:30:45.100 : DateTime\n\n    -- dateTime2 == 15 Jan 2020 15:30:45.100\n    decrementMonth dateTime2 -- 15 Dec 2019 15:30:45.100 : DateTime\n\n    -- dateTime3 == 31 Dec 2019 15:30:45.100\n    decrementMonth dateTime3 -- 30 Nov 2019 15:30:45.100 : DateTime\n\n**Note:** In the first example, decrementing the `Month` causes no changes in the `Year` and `Day` parts while\non the second example it rolls backwards the `Year`. On the last example we see that the `Day` part is different\nthan the input. This is because the resulting date would be an invalid one ( _**31st of November 2019**_ ). As a result\nof this scenario we fall back to the last valid day of the given `Month` and `Year` combination.\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"decrementSeconds","comment":" Decrements the `Seconds` in a given [DateTime](DateTime#DateTime). Will also decrement `Minutes`, `Hours`, `Day`, `Month`, `Year` where applicable.\n\n    -- dateTime  == 25 Aug 2019 15:30:45.100\n    decrementSeconds dateTime -- 25 Aug 2019 15:30:44.100 : DateTime\n\n    -- dateTime2 == 1 Jan 2020 00:00:00.000\n    decrementSeconds dateTime2 -- 31 Dec 2019 23:59:59.000 : DateTime\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"decrementYear","comment":" Decrements the `Year` in a given [DateTime](DateTime#DateTime) while preserving the `Month` and `Day`.\n_The [Time](Clock#Time) related parts will remain the same._\n\n    -- dateTime  == 31 Jan 2019 15:30:45.100\n    decrementYear dateTime -- 31 Jan 2018 15:30:45.100 : DateTime\n\n    -- dateTime2 == 29 Feb 2020 15:30:45.100\n    decrementYear dateTime2 -- 28 Feb 2019 15:30:45.100 : DateTime\n\n**Note:** In the first example, decrementing the `Year` causes no changes in the `Month` and `Day` parts.\nOn the second example we see that the `Day` part is different than the input. This is because the resulting date in the `DateTime`\nwould be an invalid date ( _**29th of February 2019**_ ). As a result of this scenario we fall back to the last valid day\nof the given `Month` and `Year` combination.\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"fromDateAndTime","comment":" Create a [DateTime](DateTime#DateTime) by combining a [Date](Calendar#Date) and [Time](Clock#Time).\n\n    -- date == 26 Aug 2019\n    -- time == 12:30:45.000\n\n    fromDateAndTime date time\n    -- DateTime { date = Date { day = Day 26, month = Aug, year = Year 2019 }, time = Time { hours = Hour 12, minutes = Minute 30, seconds = Second 45, milliseconds = Millisecond 0 } } : DateTime\n\n","type":"Calendar.Date -> Clock.Time -> DateTime.DateTime"},{"name":"fromPosix","comment":" Create a `DateTime` from a [Posix](https://package.elm-lang.org/packages/elm/time/latest/Time#Posix) time.\n\n    fromPosix (Time.millisToPosix 0)\n    -- DateTime { date = Date { day = Day 1, month = Jan, year = Year 1970 }, time = Time { hours = Hour 0, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 0 } } : DateTime\n\n    fromPosix (Time.millisToPosix 1566795954000)\n    -- DateTime { date = Date { day = Day 26, month = Aug, year = Year 2019 }, time = Time { hours = Hour 5, minutes = Minute 5, seconds = Second 54, milliseconds = Millisecond 0 } } : DateTime\n\n","type":"Time.Posix -> DateTime.DateTime"},{"name":"fromRawParts","comment":" Attempts to construct a new `DateTime` object from its raw constituent parts. Returns `Nothing` if\nany parts or their combination would result in an invalid [DateTime](DateTime#DateTime).\n\n    fromRawParts { day = 26, month = Aug, year = 2019 } { hours = 12, minutes = 30, seconds = 45, milliseconds = 0 }\n    -- Just (DateTime { date = Date { day = Day 26, month = Aug, year = Year 2019 }, time = Time { hours = Hour 12, minutes = Minute 30, seconds = Second 45, milliseconds = Millisecond 0 }}) : Maybe DateTime\n\n    fromRawParts { day = 29, month = Feb, year = 2019 } { hours = 16, minutes = 30, seconds = 45, milliseconds = 0 }\n    -- Nothing : Maybe DateTime\n\n    fromRawParts { day = 15, month = Nov, year = 2019 } { hours = 24, minutes = 20, seconds = 40, milliseconds = 0 }\n    -- Nothing : Maybe DateTime\n\n","type":"Calendar.RawDate -> Clock.RawTime -> Maybe.Maybe DateTime.DateTime"},{"name":"getDate","comment":" Extract the [Date](Calendar#Date) from a `DateTime`.\n\n    -- dateTime == 25 Dec 2019 16:45:30.000\n    getDate dateTime -- 25 Dec 2019 : Calendar.Date\n\n","type":"DateTime.DateTime -> Calendar.Date"},{"name":"getDateRange","comment":" Returns an incrementally sorted [DateTime](DateTime#DateTime) list based on the **start** and **end** `DateTime` parameters.\nThe `Time` parts of the resulting list will be equal to the `Time` argument that was provided.\n_**The resulting list will include both start and end dates**_.\n\n    -- start       == 26 Feb 2020 12:30:45.000\n    -- end         == 1  Mar 2020 16:30:45.000\n    -- defaultTime == 21:00:00.000\n\n    getDateRange start end defaultTime\n    -- [ 26 Feb 2020 21:00:00.000, 27 Feb 2020 21:00:00.000, 28 Feb 2020 21:00:00.000, 29 Feb 2020 21:00:00.000, 1 Mar 2020 21:00:00.000 ] : List DateTime\n\n","type":"DateTime.DateTime -> DateTime.DateTime -> Clock.Time -> List.List DateTime.DateTime"},{"name":"getDatesInMonth","comment":" Returns a list of [DateTimes](DateTime#DateTime) for the given `Year` and `Month` combination.\nThe `Time` parts of the resulting list will be equal to the `Time` portion of the [DateTime](DateTime#DateTime)\nthat was provided.\n\n    -- dateTime == 26 Aug 2019 21:00:00.000\n\n    getDatesInMonth dateTime\n    --   [ 1  Aug 2019  21:00:00.000\n    --   , 2  Aug 2019  21:00:00.000\n    --   , 3  Aug 2019  21:00:00.000\n    --   ...\n    --   , 29 Aug 2019 21:00:00.000\n    --   , 30 Aug 2019 21:00:00.000\n    --   , 31 Aug 2019 21:00:00.000\n    --   ] : List DateTime\n\n","type":"DateTime.DateTime -> List.List DateTime.DateTime"},{"name":"getDay","comment":" Extract the `Day` part of `DateTime` as an Int.\n\n    -- dateTime == 25 Dec 2019 16:45:30.000\n    getDay dateTime -- 25 : Int\n\n","type":"DateTime.DateTime -> Basics.Int"},{"name":"getDayDiff","comment":" Returns the difference in days between two [DateTimes](DateTime#DateTime).\nWe can have a negative difference of days as can be seen in the examples below.\n\n    -- dateTime  == 24 Aug 2019 12:00:00.000\n    -- dateTime2 == 24 Aug 2019 21:00:00.000\n    -- dateTime3 == 26 Aug 2019 15:45:00.000\n    getDayDiff dateTime dateTime2 -- 0 : Int\n\n    getDayDiff dateTime dateTime3 -- 2  : Int\n\n    getDayDiff dateTime3 dateTime -- -2 : Int\n\n","type":"DateTime.DateTime -> DateTime.DateTime -> Basics.Int"},{"name":"getHours","comment":" Extract the `Hour` part of `DateTime` as an Int.\n\n    -- dateTime == 25 Dec 2019 16:45:30.000\n    getHours dateTime -- 16 : Int\n\n","type":"DateTime.DateTime -> Basics.Int"},{"name":"getMilliseconds","comment":" Extract the `Millisecond` part of `DateTime` as an Int.\n\n    -- dateTime == 25 Dec 2019 16:45:30.000\n    getMilliseconds dateTime -- 0 : Int\n\n","type":"DateTime.DateTime -> Basics.Int"},{"name":"getMinutes","comment":" Extract the `Minute` part of `DateTime` as an Int.\n\n    -- dateTime == 25 Dec 2019 16:45:30.000\n    getMinutes dateTime -- 45 : Int\n\n","type":"DateTime.DateTime -> Basics.Int"},{"name":"getMonth","comment":" Extract the `Month` part of a `DateTime` as a [Month](https://package.elm-lang.org/packages/elm/time/latest/Time#Month).\n\n    -- dateTime == 25 Dec 2019 16:45:30.000\n    getMonth dateTime -- Dec : Time.Month\n\n","type":"DateTime.DateTime -> Time.Month"},{"name":"getSeconds","comment":" Extract the `Second` part of `DateTime` as an Int.\n\n    -- dateTime == 25 Dec 2019 16:45:30.000\n    getSeconds dateTime -- 30 : Int\n\n","type":"DateTime.DateTime -> Basics.Int"},{"name":"getTime","comment":" Extract the [Time](Clock#Time) from a `DateTime`.\n\n    -- dateTime == 25 Dec 2019 16:45:30.000\n    getTime dateTime -- 16:45:30.000 : Clock.Time\n\n","type":"DateTime.DateTime -> Clock.Time"},{"name":"getWeekday","comment":" Returns the weekday of a specific [DateTime](DateTime#DateTime).\n\n    -- dateTime == 26 Aug 2019 12:30:45.000\n    getWeekday dateTime -- Mon : Weekday\n\n","type":"DateTime.DateTime -> Time.Weekday"},{"name":"getYear","comment":" Extract the `Year` part of a `DateTime` as an Int.\n\n    -- dateTime == 25 Dec 2019 16:45:30.000\n    getYear dateTime -- 2019 : Int\n\n","type":"DateTime.DateTime -> Basics.Int"},{"name":"incrementDay","comment":" Increments the `Day` in a given [DateTime](DateTime#DateTime). Will also increment `Month` and `Year` where applicable.\n\n    -- dateTime  == 25 Aug 2019 15:30:45.100\n    incrementDay dateTime -- 26 Aug 2019 15:30:45.100 : DateTime\n\n    -- dateTime2 == 31 Dec 2019 15:30:45.100\n    incrementDay dateTime2 -- 1 Jan 2020 15:30:45.100 : DateTime\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"incrementHours","comment":" Increments the `Hours` in a given [DateTime](DateTime#DateTime). Will also increment `Day`, `Month`, `Year` where applicable.\n\n    -- dateTime  == 25 Aug 2019 15:30:45.100\n    incrementHours dateTime -- 25 Aug 2019 16:30:45.100 : DateTime\n\n    -- dateTime2 == 31 Dec 2019 23:00:00.000\n    incrementHours dateTime2 -- 1 Jan 2020 00:00:00.000 : DateTime\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"incrementMilliseconds","comment":" Increments the `Milliseconds` in a given [DateTime](DateTime#DateTime). Will also increment `Seconds`, `Minutes`, `Hours`, `Day`, `Month`, `Year` where applicable.\n\n    -- dateTime  == 25 Aug 2019 15:30:45.100\n    incrementMilliseconds dateTime -- 25 Aug 2019 15:30:45:101 : DateTime\n\n    -- dateTime2 == 31 Dec 2019 23:59:59.999\n    incrementMilliseconds dateTime2 -- 1 Jan 2020 00:00:00.000 : DateTime\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"incrementMinutes","comment":" Increments the `Minutes` in a given [DateTime](DateTime#DateTime). Will also increment `Hours`, `Day`, `Month`, `Year` where applicable.\n\n    -- dateTime  == 25 Aug 2019 15:30:45.100\n    incrementMinutes dateTime -- 25 Aug 2019 15:31:45.100 : DateTime\n\n    -- dateTime2 == 31 Dec 2019 23:59:00.000\n    incrementMinutes dateTime2 -- 1 Jan 2020 00:00:00.000 : DateTime\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"incrementMonth","comment":" Increments the `Month` in a given [DateTime](DateTime#DateTime). It will also roll over to the next year where applicable.\n_The [Time](Clock#Time) related parts will remain the same._\n\n    -- dateTime  == 15 Sep 2019 15:30:45.100\n    incrementMonth dateTime -- 15 Oct 2019 15:30:45.100 : DateTime\n\n    -- dateTime2 == 15 Dec 2019 15:30:45.100\n    incrementMonth dateTime2 -- 15 Jan 2020 15:30:45.100 : DateTime\n\n    -- dateTime3 == 30 Jan 2019 15:30:45.100\n    incrementMonth dateTime3 -- 28 Feb 2019 15:30:45.100 : DateTime\n\n**Note:** In the first example, incrementing the `Month` causes no changes in the `Year` and `Day` parts while on the second\nexample it rolls forward the 'Year'. On the last example we see that the `Day` part is different than the input. This is because\nthe resulting date would be an invalid one ( _**31st of February 2019**_ ). As a result of this scenario we fall back to the last\nvalid day of the given `Month` and `Year` combination.\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"incrementSeconds","comment":" Increments the `Seconds` in a given [DateTime](DateTime#DateTime). Will also increment `Minutes`, `Hours`, `Day`, `Month`, `Year` where applicable.\n\n    -- dateTime  == 25 Aug 2019 15:30:45.100\n    incrementSeconds dateTime -- 25 Aug 2019 15:30:46.100 : DateTime\n\n    -- dateTime2 == 31 Dec 2019 23:59:59.000\n    incrementSeconds dateTime2 -- 1 Jan 2020 00:00:00.000 : DateTime\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"incrementYear","comment":" Increments the `Year` in a given [DateTime](DateTime#DateTime) while preserving the `Month`, and `Day` parts.\n_The [Time](Clock#Time) related parts will remain the same._\n\n    -- dateTime  == 31 Jan 2019 15:30:45.100\n    incrementYear dateTime -- 31 Jan 2020 15:30:45.100 : DateTime\n\n    -- dateTime2 == 29 Feb 2020 15:30:45.100\n    incrementYear dateTime2 -- 28 Feb 2021 15:30:45.100 : DateTime\n\n**Note:** In the first example, incrementing the `Year` causes no changes in the `Month` and `Day` parts.\nOn the second example we see that the `Day` part is different than the input. This is because the resulting date in the `DateTime`\nwould be an invalid date ( _**29th of February 2021**_ ). As a result of this scenario we fall back to the last valid day\nof the given `Month` and `Year` combination.\n\n","type":"DateTime.DateTime -> DateTime.DateTime"},{"name":"isLeapYear","comment":" Checks if the `Year` part of the given [DateTime](DateTime#DateTime) is a leap year.\n\n    -- dateTime  == 25 Dec 2019 21:00:00.000\n    isLeapYear dateTime -- False\n\n    -- dateTime2 == 25 Dec 2020 12:00:00.000\n    isLeapYear dateTime2 -- True\n\n","type":"DateTime.DateTime -> Basics.Bool"},{"name":"setDay","comment":" Attempts to set the `Day` part of a [Calendar.Date](Calendar#Date) in a `DateTime`.\n\n    -- dateTime == 31 Jan 2019 15:30:30.000\n    setDay 25 dateTime -- Just (25 Jan 2019 15:30:30.000) : Maybe DateTime\n\n    setDay 32 dateTime -- Nothing : Maybe DateTime\n\n","type":"Basics.Int -> DateTime.DateTime -> Maybe.Maybe DateTime.DateTime"},{"name":"setHours","comment":" Attempts to set the `Hours` part of a [Clock.Time](Clock#Time) in a DateTime.\n\n    -- dateTime == 2 Jul 2019 12:00:00.000\n    setHours 23 dateTime -- Just (2 Jul 2019 23:00:00.000) : Maybe DateTime\n\n    setHours 24 dateTime -- Nothing : Maybe DateTime\n\n","type":"Basics.Int -> DateTime.DateTime -> Maybe.Maybe DateTime.DateTime"},{"name":"setMilliseconds","comment":" Attempts to set the `Milliseconds` part of a [Clock.Time](Clock#Time) in a DateTime.\n\n    -- dateTime == 2 Jul 2019 12:00:00.000\n    setMilliseconds 589 dateTime -- Just (2 Jul 2019 12:00:00.589) : Maybe DateTime\n\n    setMilliseconds 1000 dateTime -- Nothing : Maybe DateTime\n\n","type":"Basics.Int -> DateTime.DateTime -> Maybe.Maybe DateTime.DateTime"},{"name":"setMinutes","comment":" Attempts to set the `Minutes` part of a [Clock.Time](Clock#Time) in a DateTime.\n\n    -- dateTime == 2 Jul 2019 12:00:00.000\n    setMinutes 36 dateTime -- Just (2 Jul 2019 12:36:00.000) : Maybe DateTime\n\n    setMinutes 60 dateTime -- Nothing : Maybe DateTime\n\n","type":"Basics.Int -> DateTime.DateTime -> Maybe.Maybe DateTime.DateTime"},{"name":"setMonth","comment":" Attempts to set the `Month` part of a [Calendar.Date](Calendar#Date) in a `DateTime`.\n\n    -- dateTime == 31 Jan 2019 15:30:30.000\n    setMonth Aug dateTime -- Just (31 Aug 2019 15:30:30.000) : Maybe DateTime\n\n    setMonth Apr dateTime -- Nothing : Maybe DateTime\n\n","type":"Time.Month -> DateTime.DateTime -> Maybe.Maybe DateTime.DateTime"},{"name":"setSeconds","comment":" Attempts to set the `Seconds` part of a [Clock.Time](Clock#Time) in a DateTime.\n\n    -- dateTime == 2 Jul 2019 12:00:00.000\n    setSeconds 20 dateTime -- Just (2 Jul 2019 12:00:20.000) : Maybe DateTime\n\n    setSeconds 60 dateTime -- Nothing : Maybe DateTime\n\n","type":"Basics.Int -> DateTime.DateTime -> Maybe.Maybe DateTime.DateTime"},{"name":"setYear","comment":" Attempts to set the `Year` part of a [Calendar.Date](Calendar#Date) in a `DateTime`.\n\n    -- dateTime == 29 Feb 2020 15:30:30.000\n    setYear 2024 dateTime -- Just (29 Feb 2024 15:30:30.000) : Maybe DateTime\n\n    setYear 2019 dateTime -- Nothing : Maybe DateTime\n\n","type":"Basics.Int -> DateTime.DateTime -> Maybe.Maybe DateTime.DateTime"},{"name":"sort","comment":" Sorts incrementally a list of [DateTime](DateTime#DateTime).\n\n    -- dateTime  == 26 Aug 1920 12:30:45.000\n    -- dateTime2 == 26 Aug 1920 21:00:00.000\n    -- dateTime3 == 1  Jan 1970 00:00:00.000\n    -- dateTime4 == 1  Jan 1970 14:40:20.120\n    -- dateTime5 == 25 Dec 2020 14:40:20.120\n    -- dateTime6 == 25 Dec 2020 14:40:20.150\n\n    sort [ dateTime4, dateTime2, dateTime6, dateTime5, dateTime, dateTime3 ]\n    -- [ 26 Aug 1920 12:30:45.000\n    -- , 26 Aug 1920 21:00:00.000\n    -- , 1  Jan 1970 00:00:00.000\n    -- , 1  Jan 1970 14:40:20.120\n    -- , 25 Dec 2020 14:40:20.120\n    -- , 25 Dec 2020 14:40:20.120\n    -- ] : List DateTime\n\n","type":"List.List DateTime.DateTime -> List.List DateTime.DateTime"},{"name":"toMillis","comment":" Convers a `DateTime` to the equivalent milliseconds. The result is relative to the [Epoch](https://en.wikipedia.org/wiki/Unix_time).\nThis basically means that **if the DateTime provided is after the Epoch** the result will be a **positive number** representing the milliseconds\nthat have elapsed since the Epoch. Otherwise the result will be a negative number representing the milliseconds required in order to reach the Epoch.\n\n    -- dateTime  == 25 Dec 2019 19:23:45.000\n    toMillis dateTime -- 1577301825000 : Int\n\n    -- dateTime2 == 1 Jan 1970 00:00:00.000\n    toMillis dateTime2 -- 0 : Int\n\n    -- dateTime3 == 8 Jan 1920 04:36:15.000\n    toMillis dateTime3 -- -1577301825000 : Int\n\n","type":"DateTime.DateTime -> Basics.Int"},{"name":"toPosix","comment":" Converts a `DateTime` to a posix time. The result is relative to the [Epoch](https://en.wikipedia.org/wiki/Unix_time).\nThis basically means that **if the DateTime provided is after the Epoch** the result will be a **positive posix time.** Otherwise the\nresult will be a **negative posix time**.\n\n    -- dateTime  == 25 Dec 2019 19:23:45.000\n    toPosix dateTime -- Posix 1577301825000 : Posix\n\n    -- dateTime2 == 1 Jan 1970 00:00:00.000 : Posix\n    toPosix dateTime2 -- Posix 0\n\n    -- dateTime3 == 8 Jan 1920 04:36:15.000\n    toPosix dateTime3 -- Posix -1577301825000 : Posix\n\n","type":"DateTime.DateTime -> Time.Posix"}],"binops":[]}]