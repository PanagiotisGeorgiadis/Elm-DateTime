[{"name":"DateTime.Calendar","comment":" A calendar date.\n\n\n# Type definition\n\n@docs Date, RawDate\n\n\n# Creating values\n\n@docs fromPosix, fromRawParts\n\n\n# Converters\n\n@docs toMillis, monthToInt\n\n\n# Accessors\n\n@docs getYear, getMonth, getDay\n\n\n# Setters\n\n@docs setYear, setMonth, setDay\n\n\n# Incrementers\n\n@docs incrementYear, incrementMonth, incrementDay\n\n\n# Decrementers\n\n@docs decrementYear, decrementMonth, decrementDay\n\n\n# Comparers\n\n@docs compare\n\n\n# Utilities\n\n@docs getDateRange, getDatesInMonth, getDayDiff, getFollowingMonths, getPrecedingMonths, getWeekday, isLeapYear, sort\n\n\n# Constants\n\n@docs months, millisInADay\n\n","unions":[],"aliases":[{"name":"Date","comment":" A full ([Gregorian](https://en.wikipedia.org/wiki/Gregorian_calendar)) calendar date.\n","args":[],"type":"DateTime.Calendar.Internal.Date"},{"name":"RawDate","comment":" The raw representation of a calendar date.\n","args":[],"type":"{ year : Basics.Int, month : Time.Month, day : Basics.Int }"}],"values":[{"name":"compare","comment":" Compares the two given [Dates](DateTime-Calendar#Date) and returns an [Order](https://package.elm-lang.org/packages/elm/core/latest/Basics#Order).\n\n    past = fromRawParts { day = 25, month = Aug, year = 2019 }\n    future = fromRawParts { day = 26, month = Aug, year = 2019 }\n\n    Maybe.map2 compare past past   -- Just EQ\n    Maybe.map2 compare past future -- Just LT\n    Maybe.map2 compare future past -- Just GT\n\n","type":"DateTime.Calendar.Date -> DateTime.Calendar.Date -> Basics.Order"},{"name":"decrementDay","comment":" Decrements the `Day` in a given [Date](DateTime-Calendar#Date). Will also decrement `Month` and `Year` where applicable.\n\n    date = fromRawParts { day = 27, month = Aug, year = 2019 }\n    Maybe.map decrementDay date -- Just (Date { day = Day 26, month = Aug, year = Year 2019 })\n\n    date2 = fromRawParts { day = 1, month = Jan, year = 2020 }\n    Maybe.map decrementDay date2 -- Just (Date { day = Day 31, month = Dec, year = Year 2019 })\n\n","type":"DateTime.Calendar.Date -> DateTime.Calendar.Date"},{"name":"decrementMonth","comment":" Decrements the `Month` in a given [Date](DateTime-Calendar#Date). It will also roll backwards to the previous year where applicable.\n\n    date = fromRawParts { day = 15, month = Sep, year = 2019 }\n    Maybe.map decrementMonth date -- Just (Date { day = Day 15, month = Aug, year = Year 2019 })\n\n    date2 = fromRawParts { day = 15, month = Jan, year = 2020 }\n    Maybe.map decrementMonth date2 -- Just (Date { day = Day 15, month = Dec, year = Year 2019 })\n\n    date3 = fromRawParts { day = 31, month = Dec, year = 2019 }\n    Maybe.map decrementMonth date3 -- Just (Date { day = Day 30, month = Nov, year = Year 2019 })\n\n**Note:** In the first example, decrementing the `Month` causes no changes in the `Year` and `Day` parts while\non the seconds example it rolls backwards the `Year`. On the last example we see that the `Day` part is different\nthan the input. This is because the resulting date would be an invalid one ( _**31st of November 2019**_ ). As a result\nof this scenario we fall back to the last valid day of the given `Month` and `Year` combination.\n\n","type":"DateTime.Calendar.Date -> DateTime.Calendar.Date"},{"name":"decrementYear","comment":" Decrements the `Year` in a given [Date](DateTime-Calendar#Date) while preserving the `Month` and `Day` parts.\n\n    date = fromRawParts { day = 31, month = Jan, year = 2019 }\n    Maybe.map decrementYear date -- Just (Date { day = Day 31, month = Jan, year = Year 2018 })\n\n    date2 = fromRawParts { day = 29, month = Feb, year = 2020 }\n    Maybe.map decrementYear date2 -- Just (Date { day = Day 28, month = Feb, year = Year 2019 })\n\n**Note:** In the first example, decrementing the `Year` causes no changes in the `Month` and `Day` parts.\nOn the second example we see that the `Day` part is different than the input. This is because the resulting date\nwould be an invalid date ( _**29th of February 2019**_ ). As a result of this scenario we fall back to the last\nvalid day of the given `Month` and `Year` combination.\n\n","type":"DateTime.Calendar.Date -> DateTime.Calendar.Date"},{"name":"fromPosix","comment":" Construct a [Date](DateTime-Calendar#Date) from a [Posix](https://package.elm-lang.org/packages/elm/time/latest/Time#Posix) time.\nYou can construct a `Posix` time from milliseconds using the [millisToPosix](https://package.elm-lang.org/packages/elm/time/latest/Time#millisToPosix)\nfunction located in the [elm/time](https://package.elm-lang.org/packages/elm/time/latest/) package.\n\n    fromPosix (Time.millisToPosix 0)\n    -- Date { day = Day 1, month = Jan, year = Year 1970 }\n\n    fromPosix (Time.millisToPosix 1566795954000)\n    -- Date { day = Day 26, month = Aug, year = Year 2019 }\n\n    fromPosix (Time.millisToPosix 1566777600000)\n    -- Date { day = Day 26, month = Aug, year = Year 2019 }\n\nNotice that in the second and third examples the timestamps that are used are different but the resulting [Dates](DateTime-Calendar#Date) are identical.\nThis is because the [Calendar](DateTime-Calendar) module doesn't have any knowledge of `Time` which means that if we attempt to convert both of these dates back [toMillis](DateTime-Calendar#toMillis)\nthey will result in the same milliseconds. It is recommended using the [fromPosix](DateTime-DateTime#fromPosix) function provided in the [DateTime](DateTime-DateTime)\nmodule if you need to preserve both `Date` and `Time`.\n\n","type":"Time.Posix -> DateTime.Calendar.Date"},{"name":"fromRawParts","comment":" Attempt to construct a [Date](DateTime-Calendar#Date) from its (raw) constituent parts.\nReturns `Nothing` if any parts or their combination would form an invalid date.\n\n    date = { day = 25, month = Dec, year = 2019 }\n    fromRawParts date -- Just (Date { day = Day 25, month = Dec, year = Year 2019 })\n\n    date2 = { day = 29, month = Feb, year = 2019 }\n    fromRawParts date2 -- Nothing\n\n","type":"DateTime.Calendar.RawDate -> Maybe.Maybe DateTime.Calendar.Date"},{"name":"getDateRange","comment":" Returns an incrementally sorted [Date](DateTime-Calendar#Date) list based on the **start** and **end** date parameters.\n_**The resulting list will include both start and end dates**_.\n\n    start = fromRawParts { day = 26, month = Feb, year = 2020 }\n    end = fromRawParts { day = 1, month = Mar, year = 2020 }\n\n    Maybe.map2 getDateRange start end\n    -- Just\n    --   [ Date { day = Day 26, month = Feb, year = Year 2020 }\n    --   , Date { day = Day 27, month = Feb, year = Year 2020 }\n    --   , Date { day = Day 28, month = Feb, year = Year 2020 }\n    --   , Date { day = Day 29, month = Feb, year = Year 2020 }\n    --   , Date { day = Day 1, month = Mar, year = Year 2020 }\n    --   ]\n\n","type":"DateTime.Calendar.Date -> DateTime.Calendar.Date -> List.List DateTime.Calendar.Date"},{"name":"getDatesInMonth","comment":" Returns a list of [Dates](DateTime-Calendar#Date) for the given `Year` and `Month` combination.\n\n    date = fromRawParts { day = 26, month = Aug, year = 2019 }\n    Maybe.map getDatesInMonth date\n\n    -- Just\n    --   [ Date { day = 1, month = Aug, year = Year 2020 }\n    --   , Date { day = 2, month = Aug, year = Year 2020 }\n    --   , Date { day = 3, month = Aug, year = Year 2020 }\n    --   ...\n    --   , Date { day = 29, month = Aug, year = Year 2020 }\n    --   , Date { day = 30, month = Aug, year = Year 2020 }\n    --   , Date { day = 31, month = Aug, year = Year 2020 }\n    --   ]\n\n","type":"DateTime.Calendar.Date -> List.List DateTime.Calendar.Date"},{"name":"getDay","comment":" Extract the `Day` part of a [Date](DateTime-Calendar#Date).\n\n    date = fromRawParts { day = 25, month = Dec, year = 2019 }\n    Maybe.map getDay date -- Just 25\n\n","type":"DateTime.Calendar.Date -> Basics.Int"},{"name":"getDayDiff","comment":" Returns the difference in days between two [Dates](DateTime-Calendar#Date). We can have a negative difference of days as can be seen in the examples below.\n\n    past = fromRawParts { day = 24, month = Aug, year = 2019 }\n    future = fromRawParts { day = 26, month = Aug, year = 2019 }\n\n    Maybe.map2 getDayDiff past future -- Just 2\n    Maybe.map2 getDayDiff future past -- Just -2\n\n","type":"DateTime.Calendar.Date -> DateTime.Calendar.Date -> Basics.Int"},{"name":"getFollowingMonths","comment":" Returns a list with all the following months in a Calendar Year based on the `Month` argument provided.\nThe resulting list **will not include** the given `Month`.\n\n    getFollowingMonths Aug -- [ Sep, Oct, Nov, Dec ]\n\n    getFollowingMonths Dec -- []\n\n","type":"Time.Month -> List.List Time.Month"},{"name":"getMonth","comment":" Extract the `Month` part of a [Date](DateTime-Calendar#Date).\n\n    date = fromRawParts { day = 25, month = Dec, year = 2019 }\n    Maybe.map getMonth date -- Just Dec\n\n","type":"DateTime.Calendar.Date -> Time.Month"},{"name":"getPrecedingMonths","comment":" Returns a list with all the preceding months in a Calendar Year based on the `Month` argument provided.\nThe resulting list **will not include** the given `Month`.\n\n    getPrecedingMonths May -- [ Jan, Feb, Mar, Apr ]\n\n    getPrecedingMonths Jan -- []\n\n","type":"Time.Month -> List.List Time.Month"},{"name":"getWeekday","comment":" Returns the weekday of a specific [Date](DateTime-Calendar#Date).\n\n    date = fromRawParts { day = 26, month = Aug, year = 2019 }\n    getWeekday date -- Just Mon\n\n","type":"DateTime.Calendar.Date -> Time.Weekday"},{"name":"getYear","comment":" Extract the `Year` part of a [Date](DateTime-Calendar#Date).\n\n    date = fromRawParts { day = 25, month = Dec, year = 2019 }\n    Maybe.map getYear date -- Just 2019\n\n","type":"DateTime.Calendar.Date -> Basics.Int"},{"name":"incrementDay","comment":" Increments the `Day` in a given [Date](DateTime-Calendar#Date). Will also increment `Month` and `Year` where applicable.\n\n    date = fromRawParts { day = 25, month = Aug, year = 2019 }\n    Maybe.map incrementDay date -- Just (Date { day = 26, month = Aug, year = Year 2019 })\n\n    date2 = fromRawParts { day = 31, month = Dec, year = 2019 }\n    Maybe.map incrementDay date2 -- Just (Date { day = 1, month = Jan, year = Year 2020 })\n\n","type":"DateTime.Calendar.Date -> DateTime.Calendar.Date"},{"name":"incrementMonth","comment":" Increments the `Month` in a given [Date](DateTime-Calendar#Date). It will also roll over to the next year where applicable.\n\n    date = fromRawParts { day = 15, month = Sep, year = 2019 }\n    Maybe.map incrementMonth date -- Just (Date { day = Day 15, month = Oct, year = Year 2019 })\n\n    date2 = fromRawParts { day = 15, month = Dec, year = 2019 }\n    Maybe.map incrementMonth date2 -- Just (Date { day = Day 15, month = Jan, year = Year 2020 })\n\n    date3 = fromRawParts { day = 31, month = Jan, year = 2019 }\n    Maybe.map incrementMonth date3 -- Just (Date { day = 28, month = Feb, year = Year 2019 })\n\n**Note:** In the first example, incrementing the `Month` causes no changes in the `Year` and `Day` parts while on the second\nexample it rolls forward the 'Year'. On the last example we see that the `Day` part is different than the input. This is because\nthe resulting date would be an invalid one ( _**31st of February 2019**_ ). As a result of this scenario we fall back to the last\nvalid day of the given `Month` and `Year` combination.\n\n","type":"DateTime.Calendar.Date -> DateTime.Calendar.Date"},{"name":"incrementYear","comment":" Increments the `Year` in a given [Date](DateTime-Calendar#Date) while preserving the `Month` and `Day` parts.\n\n    date = fromRawParts { day = 31, month = Jan, year = 2019 }\n    Maybe.map incrementYear date -- Just (Date { day = Day 31, month = Jan, year = Year 2020 })\n\n    date2 = fromRawParts { day = 29, month = Feb, year = 2020 }\n    Maybe.map incrementYear date2 -- Just (Date { day = Day 28, month = Feb, year = Year 2021 })\n\n**Note:** In the first example, incrementing the `Year` causes no changes in the `Month` and `Day` parts.\nOn the second example we see that the `Day` part is different than the input. This is because the resulting date\nwould be an invalid date ( _**29th of February 2021**_ ). As a result of this scenario we fall back to the last valid day\nof the given `Month` and `Year` combination.\n\n","type":"DateTime.Calendar.Date -> DateTime.Calendar.Date"},{"name":"isLeapYear","comment":" Checks if the `Year` part of the given [Date](DateTime-Calendar#Date) is a leap year.\n\n    date = fromRawParts { day = 25, month = Dec, year = 2019 }\n    Maybe.map isLeapYear date -- Just False\n\n    date2 = fromRawParts { day = 25, month = Dec, year = 2020 }\n    Maybe.map isLeapYear date2 -- Just True\n\n","type":"DateTime.Calendar.Date -> Basics.Bool"},{"name":"millisInADay","comment":" Returns the milliseconds in a day.\n","type":"Basics.Int"},{"name":"monthToInt","comment":" Convert a given [Month](https://package.elm-lang.org/packages/elm/time/latest/Time#Month) to an integer starting from 1.\n\n    monthToInt Jan -- 1\n\n    monthToInt Aug -- 8\n\n","type":"Time.Month -> Basics.Int"},{"name":"months","comment":" Returns a list of all the `Months` in Calendar order.\n","type":"Array.Array Time.Month"},{"name":"setDay","comment":" Attempts to set the `Day` part of a [Date](DateTime-Calendar#Date).\n\n    date = fromRawParts { day = 31, month = Jan, year = 2019 }\n\n    Maybe.andThen (setDay 25) date -- Just (Date { day = Day 25, month = Jan, year = 2019 })\n    Maybe.andThen (setDay 32) date -- Nothing\n\n","type":"Basics.Int -> DateTime.Calendar.Date -> Maybe.Maybe DateTime.Calendar.Date"},{"name":"setMonth","comment":" Attempts to set the `Month` part of a [Date](DateTime-Calendar#Date).\n\n    date = fromRawParts { day = 31, month = Jan, year = 2019 }\n\n    Maybe.andThen (setMonth Aug) date -- Just (Date { day = Day 31, month = Aug, year = Year 2019 })\n    Maybe.andThen (setMonth Apr) date -- Nothing\n\n","type":"Time.Month -> DateTime.Calendar.Date -> Maybe.Maybe DateTime.Calendar.Date"},{"name":"setYear","comment":" Attempts to set the `Year` part of a [Date](DateTime-Calendar#Date).\n\n    date = fromRawParts { day = 29, month = Feb, year = 2020 }\n\n    Maybe.andThen (setYear 2024) date -- Just (Date { day = Day 29, month = Feb, year = Year 2024 })\n    Maybe.andThen (setYear 2019) date -- Nothing\n\n","type":"Basics.Int -> DateTime.Calendar.Date -> Maybe.Maybe DateTime.Calendar.Date"},{"name":"sort","comment":" Sorts incrementally a list of [Dates](DateTime-Calendar#Date).\n\n    past = fromRawParts { day = 26, month = Aug, year = 1920 }\n    epoch = fromRawParts { day = 1, month = Jan, year = 1970 }\n    future = fromRawParts { day = 25, month = Dec, year = 2020 }\n\n    sort (List.filterMap identity [ future, past, epoch ])\n    -- [ Date { day = Day 26, month = Aug, year = Year 1920 }\n    -- , Date { day = Day 1, month = Jan, year = Year 1970 }\n    -- , Date { day = Day 25, month = Dec, year = Year 2020 }\n    -- ]\n\n","type":"List.List DateTime.Calendar.Date -> List.List DateTime.Calendar.Date"},{"name":"toMillis","comment":" Transforms a [Date](DateTime-Calendar#Date) into milliseconds.\n\n    date = fromRawParts { day = 25, month = Dec, year = 2019 }\n    Maybe.map toMillis date -- Just 1577232000000\n\n    toMillis <| fromPosix (Time.millisToPosix 1566795954000) -- 1566777600000\n\nNotice that transforming a **date** to milliseconds will always get you midnight hours.\nThe first example above will return a timestamp that equals to **Wed 25th of December 2019 00:00:00.000**\nand the second example will return a timestamp that equals to **26th of August 2019 00:00:00.000** even though\nthe timestamp we provided in the [fromPosix](DateTime-Calendar#fromPosix) was equal to **26th of August 2019 05:05:54.000**\n\n","type":"DateTime.Calendar.Date -> Basics.Int"}],"binops":[]},{"name":"DateTime.Clock","comment":" A [24-hour clock time](https://en.wikipedia.org/wiki/24-hour_clock).\n\n\n# Type definition\n\n@docs Time, RawTime\n\n\n# Creating values\n\n@docs fromPosix, fromRawParts\n\n\n# Conversions\n\n@docs toMillis\n\n\n# Accessors\n\n@docs getHours, getMinutes, getSeconds, getMilliseconds\n\n\n# Setters\n\n@docs setHours, setMinutes, setSeconds, setMilliseconds\n\n\n# Incrementers\n\n@docs incrementHours, incrementMinutes, incrementSeconds, incrementMilliseconds\n\n\n# Decrementers\n\n@docs decrementHours, decrementMinutes, decrementSeconds, decrementMilliseconds\n\n\n# Comparers\n\n@docs compare\n\n\n# Utilities\n\n@docs sort\n\n\n# Constants\n\n@docs midnight\n\n","unions":[],"aliases":[{"name":"RawTime","comment":" An 'abstract' representation of Time and its constituent parts based on Integers.\n","args":[],"type":"{ hours : Basics.Int, minutes : Basics.Int, seconds : Basics.Int, milliseconds : Basics.Int }"},{"name":"Time","comment":" A clock time.\n","args":[],"type":"DateTime.Clock.Internal.Time"}],"values":[{"name":"compare","comment":" Compare two `Time` values.\n\n    past = fromRawParts { hours = 15, minutes = 45, seconds = 24, milliseconds = 780 }\n    future = fromRawParts { hours = 15, minutes = 45, seconds = 24, milliseconds = 800 }\n\n    Maybe.map2 compare past past -- Just EQ\n    Maybe.map2 compare past future -- Just LT\n    Maybe.map2 compare future past -- Just GT\n\n","type":"DateTime.Clock.Time -> DateTime.Clock.Time -> Basics.Order"},{"name":"decrementHours","comment":" Decrements an `Hour` inside a [Time](DateTime-Clock#Time). The [Time](DateTime-Clock#Time) will keep on cycling backwards with a\nminimum time of _00:00:00.000_. It also returns a `Bool` flag which indicates if the new `Time` has passed through the midnight hour ( 00:00:00.000 ).\nThis flag can be used in order to notify that a `Day` has passed but it is advised to use the [DateTime](DateTime-DateTime) module for these kind\nof operations since it provides all the available helpers and takes care of any [Calendar](DateTime-Calendar) changes.\n\n    time = fromRawParts { hours = 13, minutes = 15, seconds = 45, milliseconds = 750 }\n    Maybe.map decrementHours time -- Just (Time { hours = Hour 12, minutes = Minute 15, seconds = Second 45, milliseconds = Millisecond 750 }, False)\n\n    time2 = fromRawParts { hours = 0, minutes = 59, seconds = 59, milliseconds = 999 }\n    Maybe.map decrementHours time2 -- Just (Time { hours = Hour 23, minutes = Minute 59, seconds = Second 59, milliseconds = Millisecond 999 }, True)\n\n","type":"DateTime.Clock.Time -> ( DateTime.Clock.Time, Basics.Bool )"},{"name":"decrementMilliseconds","comment":" Decrements a `Millisecond` inside a [Time](DateTime-Clock#Time). The [Time](DateTime-Clock#Time) will keep on cycling backwards\nas mentioned in the [incrementHours](DateTime-Clock#decrementHours) description.\n\n    time = fromRawParts { hours = 12, minutes = 15, seconds = 0, milliseconds = 0 }\n    Maybe.map decrementMilliseconds time -- Just (Time { hours = Hour 12, minutes = Minute 14, seconds = Second 59, milliseconds = Millisecond 999 }, False)\n\n    time2 = fromRawParts { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n    Maybe.map decrementMilliseconds time2 -- Just (Time { hours = Hour 23, minutes = Minute 59, seconds = Second 59, milliseconds = Millisecond 999 }, True)\n\n","type":"DateTime.Clock.Time -> ( DateTime.Clock.Time, Basics.Bool )"},{"name":"decrementMinutes","comment":" Decrements a `Minute` inside a [Time](DateTime-Clock#Time). The [Time](DateTime-Clock#Time) will keep on cycling backwards\nas mentioned in the [incrementHours](DateTime-Clock#decrementHours) description.\n\n    time = fromRawParts { hours = 12, minutes = 15, seconds = 0, milliseconds = 0 }\n    Maybe.map decrementMinutes time -- Just (Time { hours = Hour 12, minutes = Minute 14, seconds = Second 0, milliseconds = Millisecond 0 }, False)\n\n    time2 = fromRawParts { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n    Maybe.map decrementMinutes time2 -- Just (Time { hours = Hour 23, minutes = Minute 59, seconds = Second 0, milliseconds = Millisecond 0 }, True)\n\n","type":"DateTime.Clock.Time -> ( DateTime.Clock.Time, Basics.Bool )"},{"name":"decrementSeconds","comment":" Decrements a `Second` inside a [Time](DateTime-Clock#Time). The [Time](DateTime-Clock#Time) will keep on cycling backwards\nas mentioned in the [incrementHours](DateTime-Clock#decrementHours) description.\n\n    time = fromRawParts { hours = 12, minutes = 15, seconds = 0, milliseconds = 0 }\n    Maybe.map decrementSeconds time -- Just (Time { hours = Hour 12, minutes = Minute 14, seconds = Second 59, milliseconds = Millisecond 0 }, False)\n\n    time2 = fromRawParts { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n    Maybe.map decrementSeconds time2 -- Just (Time { hours = Hour 23, minutes = Minute 59, seconds = Second 59, milliseconds = Millisecond 0 }, True)\n\n","type":"DateTime.Clock.Time -> ( DateTime.Clock.Time, Basics.Bool )"},{"name":"fromPosix","comment":" Construct a [Time](DateTime-Clock#Time) from a [Posix](https://package.elm-lang.org/packages/elm/time/latest/Time#Posix) time.\nYou can construct a `Posix` time from milliseconds using the [millisToPosix](https://package.elm-lang.org/packages/elm/time/latest/Time#millisToPosix)\nfunction located in the [elm/time](https://package.elm-lang.org/packages/elm/time/latest/) package.\n\n    fromPosix (Time.millisToPosix 0)\n    -- Time { hours = Hour 0, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 0 }\n\n    fromPosix (Time.millisToPosix 1566795954000)\n    -- Time { hours = Hour 5, minutes = Minute 5, seconds = Second 54, milliseconds = Millisecond 0 }\n\n    fromPosix (Time.millisToPosix 1566777600000)\n    -- Time { hours = Hour 0, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 0 }\n\nNotice that in the first and third examples the timestamps that are used are different but the result [Times](DateTime-Clock#Time) are identical.\nThis is because the [Clock](DateTime-Clock) module only extracts the `Hours`, `Minutes`, `Seconds` and `Milliseconds` from the given\n[Posix](https://package.elm-lang.org/packages/elm/time/latest/Time#Posix) time given. This means that if we attempt to convert both of these `Times`\nback [toMillis](DateTime-Clock#toMillis) they will result in the same milliseconds. It is recommended using the [fromPosix](DateTime-DateTime#fromPosix)\nfunction provided in the [DateTime](DateTime-DateTime) module if you need to preserve both `Date` and `Time`.\n\n","type":"Time.Posix -> DateTime.Clock.Time"},{"name":"fromRawParts","comment":" Construct a clock `Time` from raw hour, minute, second, millisecond integers.\n\n    time = { hours = 23, minutes = 15, seconds = 45, milliseconds = 999 }\n    fromRawParts time -- Just (Time { hours = Hour 23, minutes = Minute 15, seconds = Second 45, milliseconds = Millisecond 999 })\n\n    time2 = { hours = 24, minutes = 15, seconds = 45, milliseconds = 999 }\n    fromRawParts time -- Nothing\n\nNotice that the second attempt to construct a time resulted in `Nothing`. This is because the upper limit for an `Hour` is 23.\n\nThe limits are as follows:\n\n  - 0 &le; Hours &lt; 24\n  - 0 &le; Minutes &lt; 60\n  - 0 &le; Seconds &lt; 60\n  - 0 &le; Milliseconds &lt; 1000\n\n","type":"DateTime.Clock.RawTime -> Maybe.Maybe DateTime.Clock.Time"},{"name":"getHours","comment":" Extract the `Hours` part of a [Time](DateTime-Clock#Time).\n\n    time = fromRawParts { hours = 12, minutes = 15, seconds = 45, milliseconds = 500 }\n    Maybe.map getHours time -- Just 12\n\n","type":"DateTime.Clock.Time -> Basics.Int"},{"name":"getMilliseconds","comment":" Extract the `Millisecond` part of a [Time](DateTime-Clock#Time).\n\n    time = fromRawParts { hours = 12, minutes = 15, seconds = 45, milliseconds = 500 }\n    Maybe.map getMilliseconds time -- Just 500\n\n","type":"DateTime.Clock.Time -> Basics.Int"},{"name":"getMinutes","comment":" Extract the `Minutes` part of a [Time](DateTime-Clock#Time).\n\n    time = fromRawParts { hours = 12, minutes = 15, seconds = 45, milliseconds = 500 }\n    Maybe.map getMinutes time -- Just 15\n\n","type":"DateTime.Clock.Time -> Basics.Int"},{"name":"getSeconds","comment":" Extract the `Seconds` part of a [Time](DateTime-Clock#Time).\n\n    time = fromRawParts { hours = 12, minutes = 15, seconds = 45, milliseconds = 500 }\n    Maybe.map getSeconds time -- Just 45\n\n","type":"DateTime.Clock.Time -> Basics.Int"},{"name":"incrementHours","comment":" Increments an `Hour` inside a [Time](DateTime-Clock#Time). The [Time](DateTime-Clock#Time) will keep on cycling forward with a\nmaximum time of _23:59:59.999_. It also returns a `Bool` flag which indicates if the new `Time` has passed through the midnight hour ( 00:00:00.000 ).\nThis flag can be used in order to notify that a `Day` has passed but it is advised to use the [DateTime](DateTime-DateTime) module for these kind\nof operations since it provides all the available helpers and takes care of any [Calendar](DateTime-Calendar) changes.\n\n    time = fromRawParts { hours = 12, minutes = 15, seconds = 45, milliseconds = 750 }\n    Maybe.map incrementHours time -- Just (Time { hours = Hour 13, minutes = Minute 15, seconds = Second 45, milliseconds = Millisecond 750 }, False)\n\n    time2 = fromRawParts { hours = 23, minutes = 0, seconds = 0, milliseconds = 0 }\n    Maybe.map incrementHours time2 -- Just (Time { hours = Hour 0, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 0 }, True)\n\n","type":"DateTime.Clock.Time -> ( DateTime.Clock.Time, Basics.Bool )"},{"name":"incrementMilliseconds","comment":" Increments a `Millisecond` inside a [Time](DateTime-Clock#Time). The [Time](DateTime-Clock#Time) will keep on cycling around\nas mentioned in the [incrementHours](DateTime-Clock#incrementHours) description.\n\n    time = fromRawParts { hours = 12, minutes = 59, seconds = 59, milliseconds = 999 }\n    Maybe.map incrementMilliseconds time -- Just (Time { hours = Hour 13, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 0 }, False)\n\n    time2 = fromRawParts { hours = 23, minutes = 59, seconds = 59, milliseconds = 999 }\n    Maybe.map incrementMilliseconds time2 -- Just (Time { hours = Hour 0, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 0}, True)\n\n","type":"DateTime.Clock.Time -> ( DateTime.Clock.Time, Basics.Bool )"},{"name":"incrementMinutes","comment":" Increments a `Minute` inside a [Time](DateTime-Clock#Time). The [Time](DateTime-Clock#Time) will keep on cycling around\nas mentioned in the [incrementHours](DateTime-Clock#incrementHours) description.\n\n    time = fromRawParts { hours = 12, minutes = 59, seconds = 45, milliseconds = 750 }\n    Maybe.map incrementMinutes time -- Just (Time { hours = Hour 13, minutes = Minute 0, seconds = Second 45, milliseconds = Millisecond 750 }, False)\n\n    time2 = fromRawParts { hours = 23, minutes = 59, seconds = 45, milliseconds = 750 }\n    Maybe.map incrementMinutes time2 -- Just (Time { hours = Hour 0, minutes = Minute 0, seconds = Second 45, milliseconds = Millisecond 750}, True)\n\n","type":"DateTime.Clock.Time -> ( DateTime.Clock.Time, Basics.Bool )"},{"name":"incrementSeconds","comment":" Increments a `Second` inside a [Time](DateTime-Clock#Time). The [Time](DateTime-Clock#Time) will keep on cycling around\nas mentioned in the [incrementHours](DateTime-Clock#incrementHours) description.\n\n    time = fromRawParts { hours = 12, minutes = 59, seconds = 59, milliseconds = 750 }\n    Maybe.map incrementSeconds time -- Just (Time { hours = Hour 13, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 750 }, False)\n\n    time2 = fromRawParts { hours = 23, minutes = 59, seconds = 59, milliseconds = 750 }\n    Maybe.map incrementSeconds time2 -- Just (Time { hours = Hour 0, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 750}, True)\n\n","type":"DateTime.Clock.Time -> ( DateTime.Clock.Time, Basics.Bool )"},{"name":"midnight","comment":" Returns midnight time.\n","type":"DateTime.Clock.Time"},{"name":"setHours","comment":" Attempts to set the `Hour` on an existing time.\n\n    time = fromRawParts { hours = 15, minutes = 45, seconds = 54, milliseconds = 250 }\n\n    Maybe.andThen (setHours 23) time -- Just (Time { hours = Hour 23, minutes = Minute 45, seconds = Second 54, milliseconds = Millisecond 250 })\n    Maybe.andThen (setHours 24) time -- Nothing\n\n","type":"Basics.Int -> DateTime.Clock.Time -> Maybe.Maybe DateTime.Clock.Time"},{"name":"setMilliseconds","comment":" Attempts to set the `Millisecond` on an existing time.\n\n    time = fromRawParts { hours = 15, minutes = 45, seconds = 54, milliseconds = 250 }\n\n    Maybe.andThen (setMilliseconds 589) time -- Just (Time { hours = Hour 15, minutes = Minute 45, seconds = Second 54, milliseconds = Millisecond 589 })\n    Maybe.andThen (setMilliseconds 1000) time -- Nothing\n\n","type":"Basics.Int -> DateTime.Clock.Time -> Maybe.Maybe DateTime.Clock.Time"},{"name":"setMinutes","comment":" Attempts to set the `Minute` on an existing time.\n\n    time = fromRawParts { hours = 15, minutes = 45, seconds = 54, milliseconds = 250 }\n\n    Maybe.andThen (setMinutes 36) time -- Just (Time { hours = Hour 15, minutes = Minute 36, seconds = Second 54, milliseconds = Millisecond 250 })\n    Maybe.andThen (setMinutes 60) time -- Nothing\n\n","type":"Basics.Int -> DateTime.Clock.Time -> Maybe.Maybe DateTime.Clock.Time"},{"name":"setSeconds","comment":" Attempts to set the `Second` on an existing time.\n\n    time = fromRawParts { hours = 15, minutes = 45, seconds = 54, milliseconds = 250 }\n\n    Maybe.andThen (setSeconds 20) time -- Just (Time { hours = Hour 15, minutes = Minute 45, seconds = Second 20, milliseconds = Millisecond 250 })\n    Maybe.andThen (setSeconds 60) time -- Nothing\n\n","type":"Basics.Int -> DateTime.Clock.Time -> Maybe.Maybe DateTime.Clock.Time"},{"name":"sort","comment":" Sorts a List of 'Time' based on their representation in milliseconds.\n\n    midnight = fromRawParts { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n    dawn = fromRawParts { hours = 6, minutes = 0, seconds = 0, milliseconds = 0 }\n    noon = fromRawParts { hours = 12, minutes = 0, seconds = 0, milliseconds = 0 }\n    dusk = fromRawParts { hours = 18, minutes = 0, seconds = 0, milliseconds = 0 }\n\n    sort (List.filterMap identity [ noon, dawn, dusk, midnight ])\n    -- [ Time { hours = Hour 0, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 0 }\n    -- , Time { hours = Hour 6, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 0 }\n    -- , Time { hours = Hour 12, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 0 }\n    -- , Time { hours = Hour 18, minutes = Minute 0, seconds = Second 0, milliseconds = Millisecond 0 }\n    -- ]\n\n","type":"List.List DateTime.Clock.Time -> List.List DateTime.Clock.Time"},{"name":"toMillis","comment":" Convert a `Time` to milliseconds.\n\n    time = fromRawParts { hours = 12, minutes = 30, seconds = 0, milliseconds = 0 }\n    Maybe.map toMillis time -- Just 45000000\n\n    toMillis <| fromPosix (Time.millisToPosix 1566777600000) -- 0\n\n","type":"DateTime.Clock.Time -> Basics.Int"}],"binops":[]},{"name":"DateTime.DateTime","comment":" A complete datetime type.\n\n@docs DateTime\n\n\n# Creating a `DateTime`\n\n@docs fromPosix, fromRawParts, fromDateAndTime\n\n\n# Conversions\n\n@docs toPosix, toMillis\n\n\n# Accessors\n\n@docs getDate, getTime, getYear, getMonth, getDay, getHours, getMinutes, getSeconds, getMilliseconds\n\n\n# Setters\n\n@docs setYear, setMonth, setDay, setHours, setMinutes, setSeconds, setMilliseconds\n\n\n# Incrementers\n\n@docs incrementYear, incrementMonth, incrementDay, incrementHours, incrementMinutes, incrementSeconds, incrementMilliseconds\n\n\n# Decrementers\n\n@docs decrementYear, decrementMonth, decrementDay, decrementHours, decrementMinutes, decrementSeconds, decrementMilliseconds\n\n\n# Comparers\n\n@docs compare, compareDates, compareTime\n\n\n# Utilities\n\n@docs getWeekday, getDateRange, getDatesInMonth, sort\n\n","unions":[],"aliases":[{"name":"DateTime","comment":" An instant in time, composed of a calendar date, clock time and time zone.\n","args":[],"type":"DateTime.DateTime.Internal.DateTime"}],"values":[{"name":"compare","comment":" Compares two DateTimes and returns their 'Order'.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime -> Basics.Order"},{"name":"compareDates","comment":" Returns the 'Order' of the 'Date' part of two DateTimes.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime -> Basics.Order"},{"name":"compareTime","comment":" Returns the 'Order' of the 'Time' part of two DateTimes.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime -> Basics.Order"},{"name":"decrementDay","comment":" Decrements the 'Day' in a given 'Date'. Will also decrement 'Month' && 'Year'\n--- if applicable.\n\n> date = fromRawParts { day = 1, month = Jan, year = 2019 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> decrementDay date\n> DateTime { date = { day = Day 31, month = Dec, year = Year 2018 }, time = { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 } }\n>\n> date2 = fromRawParts { day = 1, month = Mar, year = 2020 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> decrementDay date2\n> DateTime { date = { day = Day 29, month = Feb, year = Year 2020 }, time = { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 } }\n>\n> date3 = fromRawParts { day = 26, month = Dec, year = 2018 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> decrementDay date3\n> DateTime { date = { day = Day 25, month = Dec, year = Year 2018 }, time = { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 } }\n\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"decrementHours","comment":" Decrements the 'Hours' in a given 'Date'. Will also decrement 'Day', 'Month', 'Year' where applicable.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"decrementMilliseconds","comment":" Decrements the 'Milliseconds' in a given 'Date'. Will also decrement 'Seconds', 'Minutes', 'Hours', 'Day', 'Month', 'Year' where applicable.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"decrementMinutes","comment":" Decrements the 'Minutes' in a given 'Date'. Will also decrement 'Hours', 'Day', 'Month', 'Year' where applicable.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"decrementMonth","comment":" Returns a new 'DateTime' with an updated month value.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"decrementSeconds","comment":" Decrements the 'Seconds' in a given 'Date'. Will also decrement 'Minutes', 'Hours', 'Day', 'Month', 'Year' where applicable.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"decrementYear","comment":" Returns a new 'DateTime' with an updated year value.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"fromDateAndTime","comment":" Create a `DateTime` from a 'Date' and 'Time'.\n","type":"DateTime.Calendar.Date -> DateTime.Clock.Time -> DateTime.DateTime.DateTime"},{"name":"fromPosix","comment":" Create a `DateTime` from a time zone and posix time.\n\n> fromPosix (Time.millisToPosix 0) |> year\n> Year 1970 : Year\n\n","type":"Time.Posix -> DateTime.DateTime.DateTime"},{"name":"fromRawParts","comment":" Attempts to construct a new DateTime object from its raw constituent parts.\n","type":"DateTime.Calendar.RawDate -> DateTime.Clock.RawTime -> Maybe.Maybe DateTime.DateTime.DateTime"},{"name":"getDate","comment":" Extract the calendar date from a `DateTime`.\n\n> getDate (fromPosix (Time.millisToPosix 0))\n> Date { day = Day 1, month = Jan, year = Year 1970 } : Calendar.Date\n\n","type":"DateTime.DateTime.DateTime -> DateTime.Calendar.Date"},{"name":"getDateRange","comment":" Returns a List of dates based on the start and end 'DateTime' given as parameters.\n--- The resulting list includes both the start and end 'Dates'.\n--- In the case of startDate > endDate the resulting list would still be\n--- a valid sorted date range list.\n\n> startDate = fromRawParts { day = 25, month = Feb, year = 2020 }\n> endDate = fromRawParts { day = 1, month = Mar, year = 2020 }\n> getDateRange startDate endDate Clock.midnight\n> [ Date { day = Day 25, month = Feb, year = Year 2020 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> , Date { day = Day 26, month = Feb, year = Year 2020 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> , Date { day = Day 27, month = Feb, year = Year 2020 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> , Date { day = Day 28, month = Feb, year = Year 2020 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> , Date { day = Day 29, month = Feb, year = Year 2020 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> , Date { day = Day 1, month = Mar, year = Year 2020 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> ]\n>\n> startDate2 = fromRawParts { day = 25, month = Feb, year = 2019 }\n> endDate2 = fromRawParts { day = 1, month = Mar, year = 2019 }\n> getDateRange startDate2 endDate2 Clock.midnight\n> [ Date { day = Day 25, month = Feb, year = Year 2019 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> , Date { day = Day 26, month = Feb, year = Year 2019 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> , Date { day = Day 27, month = Feb, year = Year 2019 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> , Date { day = Day 28, month = Feb, year = Year 2019 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> , Date { day = Day 1, month = Mar, year = Year 2019 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> ]\n\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime -> DateTime.Clock.Time -> List.List DateTime.DateTime.DateTime"},{"name":"getDatesInMonth","comment":" Returns a list of Dates that belong in the current month of the 'DateTime'.\n","type":"DateTime.DateTime.DateTime -> DateTime.Clock.Time -> List.List DateTime.DateTime.DateTime"},{"name":"getDay","comment":" Returns the 'Day' from a 'DateTime' as an Int.\n\n> getDay (fromPosix (Time.millisToPosix 0))\n> 1 : Int\n\n","type":"DateTime.DateTime.DateTime -> Basics.Int"},{"name":"getHours","comment":" Returns the 'Hour' from a 'DateTime' as an Int.\n\n> getHours (fromPosix (Time.millisToPosix 0))\n> 0 : Int\n\n","type":"DateTime.DateTime.DateTime -> Basics.Int"},{"name":"getMilliseconds","comment":" Returns the 'Millisecond' from a 'DateTime' as an Int.\n\n> getMilliseconds (fromPosix (Time.millisToPosix 0))\n> 0 : Int\n\n","type":"DateTime.DateTime.DateTime -> Basics.Int"},{"name":"getMinutes","comment":" Returns the 'Minute' from a 'DateTime' as an Int.\n\n> getMinutes (fromPosix (Time.millisToPosix 0))\n> 0 : Int\n\n","type":"DateTime.DateTime.DateTime -> Basics.Int"},{"name":"getMonth","comment":" Returns the 'Month' from a 'DateTime' as a [Month](https://package.elm-lang.org/packages/elm/time/latest/Time#Month).\n\n> getMonth (fromPosix (Time.millisToPosix 0))\n> Jan : Int\n\n","type":"DateTime.DateTime.DateTime -> Time.Month"},{"name":"getSeconds","comment":" Returns the 'Second' from a 'DateTime' as an Int.\n\n> getSeconds (fromPosix (Time.millisToPosix 0))\n> 0 : Int\n\n","type":"DateTime.DateTime.DateTime -> Basics.Int"},{"name":"getTime","comment":" Extract the clock time from a `DateTime`.\n\n> getTime (fromPosix (Time.millisToPosix 0))\n> Time { hour = Hour 0, millisecond = 0, minute = Minute 0, second = Second 0 } : Clock.Time\n\n","type":"DateTime.DateTime.DateTime -> DateTime.Clock.Time"},{"name":"getWeekday","comment":" Extract the weekday from a `DateTime`.\n\n> getWeekday (fromPosix (Time.millisToPosix 0))\n> Thu : Time.Weekday\n\n","type":"DateTime.DateTime.DateTime -> Time.Weekday"},{"name":"getYear","comment":" Returns the 'Year' from a 'DateTime' as an Int.\n\n> getYear (fromPosix (Time.millisToPosix 0))\n> 1970 : Int\n\n","type":"DateTime.DateTime.DateTime -> Basics.Int"},{"name":"incrementDay","comment":" Increments the 'Day' in a given 'Date'. Will also increment 'Month' && 'Year'\n--- if applicable.\n\n> date = fromRawParts { day = 31, month = Dec, year = 2018 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> incrementDay date\n> DateTime { date = { day = Day 1, month = Jan, year = Year 2019 }, time = { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 } }\n>\n> date2 = fromRawParts { day = 29, month = Feb, year = 2020 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> incrementDay date2\n> DateTime { date = { day = Day 1, month = Mar, year = Year 2020 }, time = { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 } }\n>\n> date3 = fromRawParts { day = 24, month = Dec, year = 2018 } { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 }\n> incrementDay date3\n> DateTime { date = { day = Day 25, month = Dec, year = Year 2018 }, time = { hours = 0, minutes = 0, seconds = 0, milliseconds = 0 } }\n\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"incrementHours","comment":" Increments the 'Hours' in a given 'Date'. Will also increment 'Day', 'Month', 'Year' where applicable.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"incrementMilliseconds","comment":" Increments the 'Milliseconds' in a given 'Date'. Will also increment 'Seconds', 'Minutes', 'Hours', 'Day', 'Month', 'Year' where applicable.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"incrementMinutes","comment":" Increments the 'Minutes' in a given 'Date'. Will also increment 'Hours', 'Day', 'Month', 'Year' where applicable.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"incrementMonth","comment":" Returns a new 'DateTime' with an updated month value.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"incrementSeconds","comment":" Increments the 'Seconds' in a given 'Date'. Will also increment 'Minutes', 'Hours', 'Day', 'Month', 'Year' where applicable.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"incrementYear","comment":" Returns a new 'DateTime' with an updated year value.\n","type":"DateTime.DateTime.DateTime -> DateTime.DateTime.DateTime"},{"name":"setDay","comment":" Attempts to set the 'Day' part of a Calendar.Date in a DateTime.\n","type":"Basics.Int -> DateTime.DateTime.DateTime -> Maybe.Maybe DateTime.DateTime.DateTime"},{"name":"setHours","comment":" Attempts to set the 'Hours' part of a Clock.Time in a DateTime.\n","type":"Basics.Int -> DateTime.DateTime.DateTime -> Maybe.Maybe DateTime.DateTime.DateTime"},{"name":"setMilliseconds","comment":" Attempts to set the 'Milliseconds' part of a Clock.Time in a DateTime.\n","type":"Basics.Int -> DateTime.DateTime.DateTime -> Maybe.Maybe DateTime.DateTime.DateTime"},{"name":"setMinutes","comment":" Attempts to set the 'Minutes' part of a Clock.Time in a DateTime.\n","type":"Basics.Int -> DateTime.DateTime.DateTime -> Maybe.Maybe DateTime.DateTime.DateTime"},{"name":"setMonth","comment":" Attempts to set the 'Month' part of a Calendar.Date in a DateTime.\n","type":"Time.Month -> DateTime.DateTime.DateTime -> Maybe.Maybe DateTime.DateTime.DateTime"},{"name":"setSeconds","comment":" Attempts to set the 'Seconds' part of a Clock.Time in a DateTime.\n","type":"Basics.Int -> DateTime.DateTime.DateTime -> Maybe.Maybe DateTime.DateTime.DateTime"},{"name":"setYear","comment":" Attempts to set the 'Year' part of a Calendar.Date in a DateTime.\n","type":"Basics.Int -> DateTime.DateTime.DateTime -> Maybe.Maybe DateTime.DateTime.DateTime"},{"name":"sort","comment":" Sorts a List of 'DateTime' based on their posix timestamps.\n","type":"List.List DateTime.DateTime.DateTime -> List.List DateTime.DateTime.DateTime"},{"name":"toMillis","comment":" Convers a 'DateTime' to the equivalent milliseconds since epoch.\n\n> toMillis (fromPosix (Time.millisToPosix 0))\n> 0 : Int\n\n","type":"DateTime.DateTime.DateTime -> Basics.Int"},{"name":"toPosix","comment":" Converts a 'DateTime' to a posix time.\n\n> toPosix (fromPosix (Time.millisToPosix 0))\n> Posix 0 : Time.Posix\n\n","type":"DateTime.DateTime.DateTime -> Time.Posix"}],"binops":[]}]